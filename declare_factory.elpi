macro @mixin :- gref.
macro @mixins :- coq.gref.set.

macro @class :- gref.
macro @factory :- gref.
macro @structure :- @inductive.

namespace hierarchy {

/*
    % example: params ""module"" 1
    % example: params ""algebra"" 1
    pred params i:@mixin, o:int. % maybe o:list term.

    kind dep type.
    type dep-param (term -> dep) -> dep.
    type dep-mixin list (pair @mixin (list term)) -> dep.

    % example: dep1 ""module""  (dep-mixin [pr ""zmod"" []])
    %          dep1 ""algebra"" (dep-param x\ [""ring"", ""module"" x])
    %          dep1 ""vspace""  (dep-param f\ [""zmod"",""module"" (app [""proj"",f])])
*/

    % for now lists, later proper sets

pred def  o:@class,  o:@structure,    o:list @mixin. % order matters


% but comparison should be set-like
pred dep1 i:@mixin,      o:list @mixin. % order matters

pred dep  i:@mixins,     o:@mixins.
dep MS Closure :- std.spy-do! [
  coq.gref.set.elements MS ML,
  std.fold ML {coq.gref.set.empty} dep.aux Closure
].

pred dep.aux i:gref, i:coq.gref.set, o:coq.gref.set.
dep.aux M ACC ACC :- coq.gref.set.mem M ACC, !.
dep.aux M ACC ACC1 :- std.spy-do! [
  dep1 M ML,
  std.fold ML {coq.gref.set.empty} coq.gref.set.add MS,
  coq.gref.set.union ACC {coq.gref.set.union MS {dep MS}} ACC1
].

% [factory F Requires Provides]
pred factory i:@factory, o:list @mixin, o:list @mixin. % FIXME: order irrelevant
pred from o:@factory, o:@mixin, o:term.


fill-db P :-
  term->gr {{ TYPE.class_of }} Class_TYPE,
  term->gr {{ ASG.class_of }} Class_ASG,
  term->gr {{ AG.class_of }} Class_AG,
  term->gr {{ RING.class_of }} Class_RING,


  term->gr {{ ASG_input.from_type }} MIXIN_ASG,
  term->gr {{ AG_input.from_asg }} MIXIN_AG,
  term->gr {{ RING_input.from_ag }} MIXIN_RING,

  term->gr {{ RING_input.from_asg }} FACTORY_ASG_RING,

  {{ ASG_input.from_asg_to_ASG_mixin }} = Asg_from_asg_to_ASG_mixin,
  {{ RING_factory.from_asg_to_RING_mixin }} = Ring_from_asg_to_RING_mixin,
  {{ RING_factory.from_asg_to_AG_mixin }} = Ring_from_asg_to_AG_mixin,
  {{ RING_factory.from_asg_to_ASG_mixin }} = Ring_from_asg_to_ASG_mixin,

  {{ RING.type }} = global (indt Ring_type),
  {{ ASG.type }} = global (indt Asg_type),
  {{ AG.type }} = global (indt Ag_type),
  {{ TYPE.type }} = global (indt Type_type),

  [
  def Class_TYPE Type_type [],

  def Class_ASG Asg_type [ MIXIN_ASG ],
  dep1 MIXIN_ASG [],
  factory MIXIN_ASG [] [ MIXIN_ASG ], % added by declare_mixin
  from MIXIN_ASG MIXIN_ASG From_asg_to_ASG_mixin,

  def Class_AG Ag_type [ MIXIN_ASG, MIXIN_AG ],
  dep1 MIXIN_AG [ MIXIN_ASG ],
  factory MIXIN_AG [ MIXIN_ASG ] [ MIXIN_AG ], % added by declare_mixin
  % 2 missing from

  def Class_RING Ring_type [ MIXIN_ASG, MIXIN_AG, MIXIN_RING ],
  dep1 MIXIN_RING [ MIXIN_ASG ],
  factory MIXIN_RING [ MIXIN_ASG, MIXIN_AG ] [ MIXIN_RING ], % added by declare_mixin
  % 3 missing from

  % declare_factory takes terms such as Ring_from_asg_to_AG_mixin
  % and Ring_from_asg_to_RING_mixin
  from FACTORY_ASG_RING MIXIN_ASG  Ring_from_asg_to_ASG_mixin,      % synthesized and declared as part of command ... 
  from FACTORY_ASG_RING MIXIN_AG   Ring_from_asg_to_AG_mixin,       % given
  from FACTORY_ASG_RING MIXIN_RING Ring_from_asg_to_RING_mixin,     % given 
  factory FACTORY_ASG_RING [ MIXIN_ASG ] [ MIXIN_AG, MIXIN_RING ],  % inferred

  ] => P.

main [int 1] :-
  term->gr {{ RING_input.from_ag }} MIXIN,
  coq.gref.set.empty E,
  coq.gref.set.add MIXIN E START,
  fill-db (dep START DEPS),
  coq.say START "deps=" DEPS.

pred extract-mix i:prop, o:@mixin.
extract-mix (from _ X _) X.

generate Factory ML :- std.do! [
  std.findall (from Factory Mix Bla) All,
  coq.say All,
  std.map All extract-mix ML
].

assoc [pr X Y|_] X Y.
assoc [_|L] X R :- assoc L X R.

pred synthesize i:list @mixin, i:term, o:record-decl.
synthesize [] _ end-record.
synthesize [GR|ML] T (field ff Name Type Decl) :-
  coq.gr->string GR LongName,
  rex_replace "^.*\\.\\([^\\.]+\\)\\.[^\\.]+$" "\\1_mixin" LongName Name, % TODO: do better than crap
  dep1 GR Deps,
  def (indt ClassOf) Structure Deps,
  coq.env.indt ClassOf _ _ _ _ [Class] _,
  coq.env.indt Structure _ _ _ _ [Pack] _,
  std.map Deps field-for Args,
  Type = app[ global GR, app[global(indc Pack), T, app[global (indc Class), T | Args ] ] ],
  pi f\
    field-for GR f =>
    synthesize ML T (Decl f).

toposort X X. % TODO

% declare_structure
main [str F| TODO] :-
  coq.locate F GRF,
  fill-db (
    generate GRF MLUnsorted,
    toposort MLUnsorted ML,
    pi T\
      synthesize ML T (RDecl T),
    RecordDeclaration =
      parameter `T` {{ Type }} T\
        record "class_of" {{ Type }} "Class" (RDecl T)
  ),
  coq.typecheck-indt-decl RecordDeclaration,
  coq.env.add-indt RecordDeclaration Class.


}
