shorten std.{ do!, assert! }.

% ============= preliminaries, should go in coq-lib.elpi ========================

% Reification of vernacular commands, so that we can eventually print them
kind vernac type.
type begin-module @id -> vernac.
type end-module vernac.
type declare-inductive indt-decl -> term -> vernac.
type declare-coercion coercion -> @global? -> vernac.
type declare-constant @id -> term -> term -> vernac.
type declare-instance gref -> vernac.

% Vernacular commands interpreter
pred interp-vernac i:vernac.
interp-vernac (begin-module M)         :- coq.env.begin-module M _.
interp-vernac (end-module)             :- coq.env.end-module _.
interp-vernac (declare-inductive D I)  :- coq.env.add-indt D I.
interp-vernac (declare-coercion C G)   :- coq.coercion.declare C G.
interp-vernac (declare-constant N B T) :- coq.env.add-const N B T ff _.
interp-vernac (declare-instance GR)     :- coq.CS.declare-instance GR.

% Writer monad, so that we can log the vernacular commands being executed
pred do!-monad i:list (A -> A -> prop), i:A, o:A.
do!-monad [] X X.
do!-monad [P|PS] A0 AN :- P A0 A1, !, do!-monad PS A1 AN.

pred pure i:prop, i:A, o:A.
pure P X X :- std.spy P.

pred log1 i:(A -> prop), i:A, i:list A, o:list A.
log1 F X L [X|L] :- std.spy (F X).

pred logn i:(A -> prop), i:list A, i:list A, o:list A.
logn F XS L0 LN :-
  std.map XS (x\r\ r = log1 F x) LXS,
  do!-monad LXS L0 LN.

% ======================== actual code ====================================

pred build-class_of
  i:@constructor, % BASE.Pack
  i:@inductive, % BASE.class_of
  i:@inductive, % MIX.from_BASE.type
  o:indt-decl.

build-class_of Pack Class_of Mix RD :-
  RD = (parameter `A` (sort (typ U_)) a\
        record "class_of" (sort (typ V_)) "Class" (
          field _ "base"  (app [global (indt Class_of),a]) base\
          field _ "mixin" (app [global (indt Mix),
                               app[global (indc Pack),a,base]]) mixin\
        end-record)),
  coq.typecheck-indt-decl RD.

pred build-type
  i:@inductive, % class_of
  o:indt-decl.

build-type Class RD :-
  RD = (record "type" (sort (typ U_)) "Pack" (
          field _ "sort"     (sort (typ V_)) s\
          field _ "class"    (app [global (indt Class),s]) _\
        end-record)),
  coq.typecheck-indt-decl RD.

% [red-proj-iota P K] reduces "P (K x _) -> x"
pred red-proj-iota
  i:gref, % projection
  i:gref, % constructor,
  i:term,
  o:term.
red-proj-iota Proj Konstr A B :-
  (pi X X1\ copy (app [global Proj,app[global Konstr,X,_]]) X1 :- !, copy X X1)
  => copy A B.

% lifts an operation from the mixin to the new type
pred build-operation
  i:@inductive, % NEW.type
  i:@constant, % NEW.mixin
  i:@constant, % NEW.class
  i:gref, % BASE.sort
  i:gref, % BASE.pack
  i:@constant, % Mix.op
  o:vernac.

build-operation T M C Bsort Bpack Op (declare-constant Name Bo Ty) :- !,
  coq.gr->id (const Op) Name, % we pick the same name
  Mixin = global (const M),
  Class = global (const C),
  Operation = global (const Op),
  Type = global (indt T),
  % For now we elaborate, but I'd prefer to fill in the holes myself
  coq.elaborate {{ fun T : lp:Type => lp:Operation _ (lp:Mixin _ (lp:Class T)) }} ITy Bo,
  red-proj-iota Bsort Bpack ITy Ty.

pred build-structure
  i:@id,            % New
  i:@constant,      % BASE.sort
  i:@constructor,   % BASE.Pack
  i:@inductive,     % BASE.class_of
  i:@inductive,     % MIX.from_BASE.type
  i:list @constant, % all the MIX.op to export
  o:list vernac.

build-structure New BaseSort BasePack BaseClassOf Mix Ops  L :- do!-monad [
  log1  interp-vernac (begin-module New),
  pure  (build-class_of BasePack BaseClassOf Mix C),
  log1  interp-vernac (declare-inductive C (global (indt ClassOf))),
  pure  (coq.locate "mixin" (const Mixin)),   % projection
  pure  (build-type ClassOf T),
  log1  interp-vernac (declare-inductive T (global (indt Type))),
  pure  (coq.locate "sort" Sort),   % projection
  pure  (coq.locate "class" (const Class)), % projection, XXX we don't define it, we let Coq do it
  log1  interp-vernac (begin-module "Exports"),
  log1  interp-vernac (declare-coercion 
               (coercion Sort _ (grefclass (indt Type)) sortclass) tt),
  pure  (std.map Ops (build-operation Type Mixin Class (const BaseSort) (indc BasePack)) Defs),
  logn  interp-vernac Defs,
  log1  interp-vernac (end-module),
  log1  interp-vernac (end-module)
] [] L.

pred locate-constant i:argument, o:@constant.
locate-constant (str S) G :- !, coq.locate S (const G).
locate-constant _ _ :- coq.error "locate-constant only works on strings".

main [str New, str BaseN, str MixN | OpsN] :- do! [

  % Extract relevant data from base module
  assert! (coq.locate-module BaseN Base) "base module not found",
  coq.env.module Base Refs,
  assert!
    (std.mem Refs (indt GRT), coq.gr->id (indt GRT) "type")
    "base module lacks field type",
  assert!
    (coq.env.indt GRT tt 0 0 (sort _) [global (indc GRC)] _, coq.gr->id (indc GRC) "Pack")
    "base module lacks constructor Pack",
  assert!
    (std.mem Refs (indt GRclass_of), coq.gr->id (indt GRclass_of) "class_of")
    "base module does not provide class_of",
    assert!
    (std.mem Refs (const GRsort), coq.gr->id (const GRsort) "sort")
    "base module does not provide sort",

  % Extract relevant data from mixin
  assert! (coq.locate MixN (indt GRM)) "mixin record not found",
  assert! % Needed? Too strict?
    (coq.env.indt GRM tt 1 1 (prod `A` (global (indt GRT)) _\ sort _) _ _)
    "mixin does not depend on base module type uniformly",
  assert! (std.map OpsN locate-constant Ops) "operations to export not found",

  % there we go
  build-structure New GRsort GRC GRclass_of GRM Ops Vernacs,

  % TODO: print properly
  coq.say {std.rev Vernacs}
].
