shorten std.{ do!, assert! }.

% ============= preliminaries, should go in coq-lib.elpi ========================

% Reification of vernacular commands, so that we can eventually print them
kind vernac type.
type begin-module @id -> vernac.
type end-module vernac.
type declare-inductive indt-decl -> @inductive -> vernac.
type declare-coercion coercion -> @global? -> vernac.
type declare-constant @id -> term -> term -> @constant -> vernac.
type declare-implicit gref -> list implicit_kind -> vernac.
type declare-instance gref -> vernac.

% Vernacular commands interpreter
pred interp-vernac i:vernac.
interp-vernac (begin-module M)           :- coq.env.begin-module M none.
interp-vernac (end-module)               :- coq.env.end-module _.
interp-vernac (declare-inductive D I)    :- coq.env.add-indt D I.
interp-vernac (declare-coercion C G)     :- coq.coercion.declare C G.
interp-vernac (declare-constant N B T G) :- coq.env.add-const N B T ff _ G.
interp-vernac (declare-instance GR)      :- coq.CS.declare-instance GR.
interp-vernac  (declare-implicit GR L)    :- coq.arguments.set-implicit GR [L] tt.

% Writer monad, so that we can log the vernacular commands being executed
pred do!-monad i:list (A -> A -> prop), i:A, o:A.
do!-monad [] X X.
do!-monad [P|PS] A0 AN :- P A0 A1, !, do!-monad PS A1 AN.

pred pure i:prop, i:A, o:A.
pure P X X :- std.spy P.

pred log1 i:(A -> prop), i:A, i:list A, o:list A.
log1 F X L [X|L] :- std.spy (F X).

pred logn i:(A -> prop), i:list A, i:list A, o:list A.
logn F XS L0 LN :-
  std.map XS (x\r\ r = log1 F x) LXS,
  do!-monad LXS L0 LN.

% ======================== actual code ====================================

pred build-class_of
  i:@constructor, % BASE.Pack
  i:@inductive, % BASE.class_of
  i:@inductive, % MIX.from_"BASE.type"
  o:indt-decl.

build-class_of Pack Class_of Mix RD :-
  RD = (parameter `A` (sort (typ U_)) a\
        record "class_of" (sort (typ V_)) "Class" (
          field _ "base"  (app [global (indt Class_of),a]) base\
          field _ "mixin" (app [global (indt Mix),
                               app[global (indc Pack),a,base]]) mixin\
        end-record)),
  coq.typecheck-indt-decl RD.

pred build-type
  i:@inductive, % NEW.class_of
  o:indt-decl.

build-type ClassOf RD :-
  RD = (record "type" (sort (typ U_)) "Pack" (
          field _ "sort"     (sort (typ V_)) s\
          field _ "class"    (app [global (indt ClassOf),s]) _\
        end-record)),
  coq.typecheck-indt-decl RD.

% [red-proj-iota P K] reduces "P (K x _) -> x"
pred red-proj-iota
  i:gref, % projection
  i:gref, % constructor,
  i:term,
  o:term.
red-proj-iota Proj Konstr A B :-
  (pi X X1\ copy (app [global Proj,app[global Konstr,X,_]]) X1 :- !, copy X X1)
  => copy A B.

% lifts an operation from the mixin to the new type
pred build-operation
  i:@inductive, % NEW.type
  i:@constant, % NEW.mixin
  i:@constant, % NEW.class
  i:gref, % BASE.sort
  i:gref, % BASE.pack
  i:@constant, % Mix.op
  o:list vernac.

build-operation T M C Bsort Bpack Op [declare-constant Name Bo Ty OpC, declare-implicit (const OpC) [maximal]] :- !,
  coq.gr->id (const Op) Name, % we pick the same name
  Mixin = global (const M),
  Class = global (const C),
  Operation = global (const Op),
  Type = global (indt T),
  % For now we elaborate, but I'd prefer to fill in the holes myself
  coq.elaborate {{ fun T : lp:Type => lp:Operation _ (lp:Mixin _ (lp:Class T)) }} ITy Bo,
  % TODO: I can take the original type of Op and replace mixin type parameter
  % (A : BASE.type) with sort
  red-proj-iota Bsort Bpack ITy Ty.

pred build-structure
  i:@id,            % New
  i:@constant,      % BASE.sort
  i:@constructor,   % BASE.Pack
  i:@inductive,     % BASE.class_of
  i:@inductive,     % MIX.from_BASE.type
  i:list @constant, % all the MIX.op to export
  o:list vernac,
  o:list prop.      % clauses for hierarchy.db

build-structure New BaseSort BasePack BaseClassOf Mix Ops  L Clauses :- do!-monad [
  log1  interp-vernac (begin-module New),
  pure  (build-class_of BasePack BaseClassOf Mix C),
  log1  interp-vernac (declare-inductive C ClassOf),
  pure  (coq.locate "mixin" (const Mixin)),   % projection
  pure  (build-type ClassOf T),
  log1  interp-vernac (declare-inductive T Type),
  pure  (coq.locate "sort" Sort),   % projection
  pure  (coq.locate "class" (const Class)), % projection, XXX we don't define it, we let Coq do it
% TODO: define coercions to all super structures  
  log1  interp-vernac (begin-module "Exports"),
  log1  interp-vernac (declare-coercion 
               (coercion Sort _ (indt Type) sortclass) tt),
  pure  (std.map Ops (build-operation Type Mixin Class (const BaseSort) (indc BasePack)) DefsL),
  pure  (std.flatten DefsL Defs),
  logn  interp-vernac Defs,
% TODO: export all coercions
% TODO: declare all coercions as canonical
  log1  interp-vernac (end-module),
  log1  interp-vernac (end-module),
  pure  (Clauses = [(pi Rest\ hierarchy.def (indt ClassOf) [indt Mix|Rest] :- hierarchy.def (indt BaseClassOf) Rest)])
] [] L.



% TODO: think about these APIs and implement them.
%% NOTE: a class is a label for a finite set of mixin names
% [class_containing M CL] given M that is a set of mixings, let P be the
% power set of M, then CL is the list of classes corresponding to each p \in P
pred class_containing i:closed_set mixin, o:list class.
%
% from the label to the contents
pred class_contents i:class, o:closed_set mixin.
%
% take the intersection of class_contents then class_containing, and if there is
% no such a thing we return the set of mixins so that we can build the class
% lazily
%pred pushout_class i:class, i:class, o:(class + closed_set mixin).
%
% END todo


pred locate-constant i:argument, o:@constant.
locate-constant (str S) G :- !, coq.locate S (const G).
locate-constant _ _ :- coq.error "locate-constant only works on strings".

main [str New, str BaseN, str MixN | OpsN] :- do! [

  % Extract relevant data from base module
  assert! (coq.locate-module BaseN Base) "base module not found",
  coq.env.module Base Refs,
  assert!
    (std.mem Refs (indt GRT), coq.gr->id (indt GRT) "type")
    "base module lacks field type",
  assert! % TODO: may have parameters in the future
    (coq.env.indt GRT tt 0 0 (sort _) [GRC] _, coq.gr->id (indc GRC) "Pack")
    "base module lacks constructor Pack",
  assert!
    (std.mem Refs (indt GRclass_of), coq.gr->id (indt GRclass_of) "class_of")
    "base module does not provide class_of",
    assert!
    (std.mem Refs (const GRsort), coq.gr->id (const GRsort) "sort")
    "base module does not provide sort",

  % Extract relevant data from mixin
  assert! (coq.locate MixN (indt GRM)) "mixin record not found",
  assert! % Needed? Too strict?
    (coq.env.indt GRM tt 1 1 (prod `A` (global (indt GRT)) _\ sort _) _ _)
    "mixin does not depend on base module type uniformly",
  assert! (std.map OpsN locate-constant Ops) "operations to export not found",

  % there we go
  build-structure New GRsort GRC GRclass_of GRM Ops Vernacs Clauses,

  % TODO: print properly
  coq.say {std.rev Vernacs},

  std.forall Clauses
    (x\ coq.elpi.accumulate "hierarchy.db" (clause _ _ x))
].
