

pred toposorted i: list (pair A A), i: list A.
toposorted _ [].
toposorted ES [X|XS] :-
  if (std.exists XS (y\ std.mem ES (pr y X))) fail (toposorted ES XS).

namespace ks {

%              list of edges       node(s)    visited    progress   visited'   output
pred topovisit i: list (pair A A), i: A,      i: list A, i: list A, o: list A, o: list A.
topovisit _ X VS PS VS PS :- std.mem PS X, !.
topovisit _ X VS _ _ _ :- std.mem VS X, !, print "cycle detected.", fail.
topovisit ES X VS PS VS' [X|PS'] :-
  toporec ES {std.map {std.filter ES (e\ fst e X)} snd} [X|VS] PS VS' PS'.

pred toporec   i: list (pair A A), i: list A, i: list A, i: list A, o: list A, o: list A.
toporec _ [] VS PS VS PS.
toporec ES [X|XS] VS PS VS'' PS'' :-
  topovisit ES X VS PS VS' PS', toporec ES XS VS' PS' VS'' PS''.

pred toposort i: list (pair A A), i: list A, o: list A.
toposort ES XS XS' :- toporec ES XS [] [] _ XS'.

pred main i: list (pair A A), i: list A, o:list A.
main ES XS XS' :-
  toposort ES XS XS'.

}

% missing
type (=>) list prop -> list prop -> prop.

namespace et {

pred deps i:list (pair int int), i:std.int.map (list int), o:std.int.map (list int).
deps [pr B A|ES] M M2 :-
  std.int.map.find B M D,
  std.int.map.add B [A|D] M M1,
  deps ES M1 M2.
deps [] M M.

pred vertex i:int, o:bool.

pred allocate-vertex i:int, o:prop.
allocate-vertex V (vertex V FRESH_).

pred solution-tail-ptr o:list int.
pred write-solution i:int.
write-solution V :- declare_constraint (write-solution V) [_].
pred end-solution.
end-solution :- declare_constraint end-solution [_].
pred start-solution i:list int.
start-solution S :- declare_constraint (solution-tail-ptr S) [_].

constraint write-solution solution-tail-ptr end-solution {
  rule \ (write-solution V) (solution-tail-ptr L) <=>
    (L =[V|VS], declare_constraint (solution-tail-ptr VS) [_]).
  rule \ end-solution (solution-tail-ptr L) <=>
    (L = []).
}

pred suspend-on i:bool, i:prop.
suspend-on T P :- declare_constraint P [T].

pred solve i:list bool, i:int.
solve [] V :- write-solution V, vertex V tt.
solve [T|TS] V :- var T, !, suspend-on T (solve TS V).
solve [_|TS] V :- solve TS V.

pred compile-vertex i:std.int.map (list int), i:int, o:prop.
compile-vertex M V (solve Triggers V) :-
  std.int.map.find V M Deps,
  std.map Deps vertex Triggers.

pred main i:list (pair int int), i:list int, o:list int.
main E V S :-
  std.fold V {std.int.map.empty} (v\std.int.map.add v []) M0,
  deps E M0 M,

  std.map V allocate-vertex Triggers,
  Triggers => std.map V (compile-vertex M) Goals,

  start-solution SOL,
  Triggers => Goals,
  end-solution,

  std.rev SOL S.

}

main :-
  Edges = [pr 7 11, pr 7 8, pr 5 11, pr 3 8, pr 3 10, pr 11 2, pr 11 9, pr 11 10, pr 8 9],
  Vertices = [3, 2, 5, 7, 8, 9, 10, 11],
  ks.main Edges Vertices Solution,
  print Solution,
  et.main Edges Vertices Solution1,
  print Solution1,
  toposorted Edges Solution,
  toposorted Edges Solution1.





