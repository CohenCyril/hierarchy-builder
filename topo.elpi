

pred toposorted i: list (pair A A), i: list A.
toposorted _ [].
toposorted ES [X|XS] :-
  if (std.exists XS (y\ std.mem ES (pr y X))) fail (toposorted ES XS).

namespace ks {

%              list of edges       node(s)    visited    progress   visited'   output
pred topovisit i: list (pair A A), i: A,      i: list A, i: list A, o: list A, o: list A.
topovisit _ X VS PS VS PS :- std.mem PS X, !.
topovisit _ X VS _ _ _ :- std.mem VS X, !, print "cycle detected.", fail.
topovisit ES X VS PS VS' [X|PS'] :-
  toporec ES {std.map {std.filter ES (e\ fst e X)} snd} [X|VS] PS VS' PS'.

pred toporec   i: list (pair A A), i: list A, i: list A, i: list A, o: list A, o: list A.
toporec _ [] VS PS VS PS.
toporec ES [X|XS] VS PS VS'' PS'' :-
  topovisit ES X VS PS VS' PS', toporec ES XS VS' PS' VS'' PS''.

pred toposort i: list (pair A A), i: list A, o: list A.
toposort ES XS XS' :- toporec ES XS [] [] _ XS'.

pred main i: list (pair A A), i: list A, o:list A.
main ES XS XS' :-
  toposort ES XS XS'.

}

namespace et {

pred deps i:list (pair int int), i:std.int.map (list int), o:std.int.map (list int).
deps [pr B A|ES] M M2 :-
  std.int.map.find B M D,
  std.int.map.add B [A|D] M M1,
  deps ES M1 M2.
deps [] M M.

pred vertex i:int, o:bool.

pred allocate-vertex i:int, o:prop.
allocate-vertex V (vertex V FRESH_).

pred solution o:list int.
pred write-solution i:int.
write-solution V :- declare_constraint (write-solution V) [_].
pred close-solution.
close-solution :- declare_constraint close-solution [_].

constraint write-solution solution close-solution {
  rule \ (write-solution V) (solution L) <=>
    (L =[V|VS], declare_constraint (solution VS) [_]).
  rule \ close-solution (solution L) <=> (L = []).
}

pred solve i:list bool, i:int.
solve [] V :- write-solution V, vertex V tt.
solve [T|TS] V :- var T, !, declare_constraint (solve TS V) [T].
solve [_|TS] V :- solve TS V.

pred compile-vertex i:std.int.map (list int), i:int.
compile-vertex M V :-
  std.int.map.find V M Deps,
  std.map Deps vertex Triggers,
  solve Triggers V.

pred main i:list (pair int int), i:list int, o:list int.
main E V S :-
  std.fold V {std.int.map.empty} (v\std.int.map.add v []) M0,
  deps E M0 M,
  std.map V allocate-vertex State,
  declare_constraint (solution SOL) [_],
  State => std.forall V (compile-vertex M),
  close-solution,
  std.rev SOL S.

}

main :-
  Edges = [pr 7 11, pr 7 8, pr 5 11, pr 3 8, pr 3 10, pr 11 2, pr 11 9, pr 11 10, pr 8 9],
  Vertices = [3, 2, 5, 7, 8, 9, 10, 11],
  ks.main Edges Vertices Solution,
  print Solution,
  et.main Edges Vertices Solution1,
  print Solution1,
  toposorted Edges Solution,
  toposorted Edges Solution1.





