
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
\usepackage{hyperref}
\usepackage{minted} % pip3 install pygments, pdflatex -shell-escape hb
\newminted[elpicode]{elpi.py:ElpiLexer -x}{linenos=true,fontsize=\footnotesize,escapeinside=\%\%}
\newmintinline[elpi]{elpi.py:ElpiLexer -x}{fontsize=\small}
\newminted[coqcode]{elpi.py:CoqElpiLexer -x}{linenos=true,fontsize=\footnotesize,mathescape,escapeinside=\#\#}
\newmintinline[coq]{elpi.py:CoqElpiLexer -x}{fontsize=\small}

\newcommand{\coqelpi}{Coq-Elpi}
\newcommand{\HB}{\ensuremath{\mathcal{HB}}}
\newcommand{\hb}{\coq{hierarchy-builder}}

%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Hierarchy Builder: algebraic~hierarchies made easy in Coq with Elpi} %TODO Please add

\titlerunning{Hierarchy Builder}%optional, please use if title is longer than one line

\author{Cyril Cohen}{Inria, France}{Cyril.Cohen@inria.fr}{}{}
\author{Kazuhiko Sakaguchi}{University of Tsukuba, Japan}{sakaguchi@coins.tsukuba.ac.jp}{}{}
\author{Enrico Tassi}{Inria, France}{Enrico.Tassi@inria.fr}{}{}
\authorrunning{C.\,Cohen and K.\,Sakaguchi and E.\,Tassi}
% \author{John Q. Public}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
% \author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}
% \authorrunning{J.\,Q. Public and J.\,R. Public}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Cyril Cohen and Kazuhiko Sakaguchi and Enrico Tassi}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{General and reference~General literature}
\ccsdesc[100]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 
\supplement{Source code of the Coq package: \url{https://github.com/math-comp/hierarchy-builder}}
\keywords{Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, $\lambda$Prolog}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: Write glossary
% remove distinction
% TODO: Structure -> Class
% TODO: packager -> ClassBuilder
% TODO: Builder -> Builder
% Factories ( primitive / general ) ; kill mixin

\newcommand{\Lang}{\ensuremath{\Lambda}}
\newcommand{\term}{term}
\newcommand{\mixin}{mixin}
\newcommand{\mixins}{mixins}
\newcommand{\Mixins}{Mixins}
\newcommand{\M}{\ensuremath{\mathcal{M}}}
\newcommand{\factory}{factory}
\newcommand{\factories}{factories}
\newcommand{\Factories}{Factories}
\newcommand{\packager}{packager}
\newcommand{\builder}{builder}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\depx}{\ensuremath{d}}
\newcommand{\dep}{\ensuremath{dep}}
\newcommand{\depone}{\ensuremath{dep_1}}
\newcommand{\powerset}[1]{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}(#1)}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\class}{class}
\newcommand{\classes}{classes}
\newcommand{\cdef}{\ensuremath{def}}
\newcommand{\Str}{\ensuremath{\mathcal{S}}}
\newcommand{\structure}{structure}
\newcommand{\structures}{structures}
\newcommand{\issubclass}{\ensuremath{sub}}
\newcommand{\subclass}{subclass}
\newcommand{\join}{\ensuremath{join}}
\newcommand{\requires}{\ensuremath{requires}}
\newcommand{\provides}{\ensuremath{provides}}
\newcommand{\from}{\ensuremath{\mathsf{from}}}
\newcommand{\proj}[2]{\ensuremath{#1[#2]}}
\newtheoremstyle{implem}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1}\thmnumber{ #2}\thmnote{ #3}}

\theoremstyle{implem}
\newtheorem*{implementation}{Implementation of}

\theoremstyle{implem}
\newtheorem*{invariant}{Programming invariant for}

\newcounter{axiomcounter}
\def\axiomcounterautorefname~#1\null{%
  Axiom~#1\null
}
\theoremstyle{axiom}
\newtheorem{axiom}[axiomcounter]{Axiom}

\newtheoremstyle{abscommand}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1}\coq{ #3}}
\theoremstyle{abscommand}
\newtheorem*{abscommand}{Command signature}

\newtheoremstyle{command}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1}\coq{ #3}}
\theoremstyle{command}
\newtheorem*{command}{Coq command}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
It is nowadays customary to organize libraries of machine checked
proofs around hierarchies of algebraic
structures~\cite{10.1145/3372885.3373824,mathclasses,DBLP:journals/mics/BoldoLM15,DBLP:conf/mpc/AffeldtNS19}.
One influential example is the Mathematical Components library on top
of which the long and intricate proof of the Odd Order
Theorem could be fully formalized~\cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13}.

Still, building algebraic hierarchies in a proof assistant such as Coq~\cite{Coq:manual}
requires a lot of manual labor and often a deep expertise in the internals of
the prover~\cite{DBLP:conf/tphol/GarillotGMR09,DBLP:conf/itp/MahboubiT13}.
Moreover, making a hierarchy evolve, e.g. splitting a structure into two
simpler ones, without causing breakage in client code is even harder,
according to our experience~\cite{KSdraft}.

In this paper we describe \HB{}, a high level language
to \emph{build} hierarchies of algebraic structures and to make these hierarchies
\emph{evolve} without breaking user code. The key concepts are the ones of
\emph{\factory{}} and \emph{\packager{}} that lets the hierarchy developer
describe an actual
interface for his library. Behind that interface the developer can provide
appropriate code to ensure retro compatibility.
We implement the \HB{} language in the \hb{} addon for the Coq
system using the Elpi~\cite{DBLP:conf/lpar/DunchevGCT15,CoqElpi}
extension language.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Modern libraries of machine checked proofs are organized around
hierarchies of algebraic structures~\cite{10.1145/3372885.3373824,mathclasses,DBLP:journals/mics/BoldoLM15,DBLP:conf/mpc/AffeldtNS19}.
For example the Mathematical Components library for the Coq system~\cite{Coq:manual}
provides a very rich, ever growing, hierarchy of structures such as
group, ring, module, algebra, field, pre-order, order, lattice\ldots
The hierarchy does not only serve the purpose of organizing knowledge, but
also to make it easy to exploit it. Indeed the interactive prover can
take advantage of the structure of the library and the relation between
its concepts to infer part of information usually left implicit
by the user. This feature turned out to be a key ingredient to tame
the complexity and size of formal proofs such as the one of the Odd Order
Theorem~\cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13}.

The hierarchy of the Mathematical Components library
is based on the discipline of Packed Classes initially introduced
in \cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13} and later also adopted in
\cite{DBLP:conf/mpc/AffeldtNS19} and \cite{DBLP:journals/mics/BoldoLM15}.
We call Packed Classes a discipline, and not a language, because, in spite of
its many virtues, it is unwieldy to use. In particular it leaks to the user
many of the technical details of the Coq system. As as result one
needs to be a Coq expert in order to build or modify a hierarchy, and even
experts make mistakes when doing that as shown in~\cite{KSdraft}.
Another inconvenience of the Packed Classes discipline is that even
simple changes to the hierarchy, such as splitting a structure into
two simpler ones, break user code.

In this paper we describe \HB{}, a high level language
to \emph{build} hierarchies of algebraic structures and to make these hierarchies
\emph{evolve} without breaking user code. The key concept is the one of
\emph{\factory{}} and \emph{\packager{}} that lets the hierarchy developer describe an actual
interface for his library. Behind that interface the developer can provide
appropriate code to ensure retro compatibility.
We implement the \HB{} language in the \hb{} addon for the Coq.
We write this addon using using the Elpi~\cite{DBLP:conf/lpar/DunchevGCT15,CoqElpi}
extension language for Coq.

The main contributions of the paper are the following ones:
\begin{itemize}
\item the \HB{} language providing linguistic tools to
build a hierarchy and make it evolve without breaking user code
\item an compilation of \HB{} to a variant of the Packed Classes discipline
that we call \emph{flat}
\item the \hb{} addon for Coq implementing \HB{}
\end{itemize}

The paper is organized as follows. Via an example in Coq we introduce
\HB{} and its key ideas. We then provide a formal description of
\HB{}. We then describe the discipline
of Packed Classes and we describe how \HB{} can be compiled to it.
We then discuss the implementation of the Coq addon via the Elpi extension
language and we position \HB{} in the literature.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{\HB{} by examples: building and evolving a hierarchy}

The first version of our hierarchy (that we name V1) features only two
structures: \coq{Monoid} and \coq{Ring}.

\begin{coqcode}
Elpi hb.declare_mixin Monoid_of_Type A.                       #\label{demo:mixin:mot}#
  Record axioms := {
    zero : A;
    add : A -> A -> A;
    addrA : associative add;              (* `add` is associative.                  *)
    add0r : left_id zero add;             (* `zero` is a left and right             *)
    addr0 : right_id zero add;            (*   absorbing element w.r.t. `add`.      *)
}.
Elpi hb.end.                                              #\label{demo:mixin:mot:end}#
Elpi hb.structure Monoid Monoid_of_Type.axioms.        #\label{demo:structure:monoid}#

Elpi hb.declare_mixin Ring_of_Monoid A Monoid.axioms.       #\label{demo:mixin:rom}#
  Record axioms := {
    one : A;
    opp : A -> A;
    mul : A -> A -> A;
    addrC : commutative (S := A) add;    (* `add` is commutative.                   *)
    addNr : left_inverse zero opp add;   (* `opp x` is the additive inverse of `x`. *)
    mulrA : associative mul;             (* `mul` is associative.                   *)
    mul1r : left_id one mul;             (* `one` is the left and right identity    *)
    mulr1 : right_id one mul;            (*   element w.r.t. `mul`.                 *)
    mulrDl : left_distributive mul add;  (* `mul` is left and right distributive    *)
    mulrDr : right_distributive mul add; (*   over `add`.                           *)
  }.
Elpi hb.end.
Elpi hb.structure Ring Monoid.axioms Ring_of_Monoid.axioms. #\label{demo:structure:ring}#

\end{coqcode}

In order to build a structure we need to declare some \factories{} and
later assemble them. One kind of \factory{} supported by \HB{}, the simplest
one, is called \mixin{} and is embodied by a record, by convention named
\coq{axioms}, that gathers operations and properties.

\Mixins{} are declared via the \coq{hb.declare_mixin} command
that takes a module name,
a type variable name and a possibly empty list of \factories{} for that type.
The code between lines~\ref{demo:mixin:mot}
and~\ref{demo:mixin:mot:end} declares a \mixin{} that can turn a naked
type \coq{A} into a monoid, hence we chose the module name to be \coq{Monoid_of_Type}.

The \coq{hb.structure} command takes in input a name S and a possibly
empty list of \factories{}
It registers a structure S in the hierarchy placing
any definition specific to that structure inside a Coq module named \coq{S}.
Line~\ref{demo:structure:monoid} hence forges a the structure \coq{Monoid}.

Line~\ref{demo:mixin:rom} declares a second \mixin{} collecting the operations
and properties that are needed in order to enrich a monoid to a ring, hence
the name \coq{Ring_of_Monoid}. Indeed this time the type variable \coq{A}
is followd by \coq{Monoid.axioms} that enriches
\coq{A} with the operations and properties of monoids. As a consequence
\coq{add} and \coq{zero} can be used to express the new properties.

The last line declares the structure \coq{Ring} to hold all the axioms declared
so far. We can now inspect the contents of the hierarchy and then
proceed to build a theory about abstract rings,
register examples (instances) of ring structures
and finally use the abstract theory on these examples.

\begin{coqcode}
Print Monoid.type. (* Monoid.type  :=  { sort : Type;  ... }                           *) #\label{demo:theory:print:type}#
Check @add.        (* add          :   forall M : Monoid.type, M -> M -> M             *) #\label{demo:theory:check:add}#
Check @addNr.      (* addNr        :   forall R : Ring.type, left_inverse zero opp add *) #\label{demo:theory:check:addNr}#

Lemma addrN : forall R : Ring.type, right_inverse zero opp add.                 #\label{demo:theory:state:addrN}#
Proof. by move=> x; rewrite addrC addNr. Qed.

Definition Z_Monoid_axioms :=                                                   #\label{demo:theory:z:monoid:axioms}#
  Monoid_of_Type.Axioms Z 0 Z.add
    Z.add_assoc Z.add_0_l Z.add_0_r.

Elpi hb.canonical Z Z_Monoid_axioms.                                            #\label{demo:theory:z:monoid:canonical}#

Definition Z_Ring_axioms :=                                                     #\label{demo:theory:z:ring:axioms}#
  Ring_of_Monoid.Axioms Z 1 Z.opp Z.mul
    Z.add_comm Z.add_opp_diag_l Z.mul_assoc Z.mul_1_l Z.mul_1_r
    Z.mul_add_distr_r Z.mul_add_distr_l.

Elpi hb.canonical Z Z_Ring_axioms.                                              #\label{demo:theory:z:ring:canonical}#

Lemma exercise (m n : Z) : (n + m) - n + 0 = m.
Proof. by rewrite (addrC n) -(addrA m) addrN !addr0. Qed.
\end{coqcode}

We can print the type for monoids as forged by \HB{} (line~\ref{demo:theory:print:type}).
It packs a carrier, called \coq{sort}, and the collection of operation and
properties that we omit for brevity.  We can also look at the type of two
constants synthesized by \HB{} out of the hierarchy declaration. Remark that
while the names of the constants come from the the names of the \mixin{} fields,
their types differ.
In particular they are quantified over a \coq{Monoid.type} or \coq{Ring.type},
and not a simple type as in the mixin. Moreover we evince that
the \coq{sort} projection is declared as an implicit coercion~\cite{Saibi97}
and is automatically inserted in order to make \coq{M -> M -> M} a meaningful
type for binary operations on the carrier of \coq{M}. Last, we see that
properties are quantified on (hence apply to) the structure they belong but
use, in their statements, operations belonging to simpler structures.
Indeed \coq{addNr} is a property of rings and its statement mentions \coq{add},\
the operation of the underlying monoid.

We then prove lemma \coq{addrN}, line~\ref{demo:theory:state:addrN}, that is
a trivial consequence of the ring axioms. Albeit simple this example shows
we can populate the theory of rings with new results.

We use the \coq{Monoid_of_Type.Axioms} \emph{\packager{}}
(line~\ref{demo:theory:z:monoid:axioms})
in order to build an instance of the \coq{Monoid}
structure for binary integers \coq{Z}.
We then register that ring instance as the canonical one on \coq{Z}
(line~\ref{demo:theory:z:monoid:canonical}) via the \HB{} command
\coq{hb.canonical}.
We can similarly declare that \coq{Z} forms a ring by using
the \coq{Ring_of_Monoid.Axioms} \packager{}
(lines~\ref{demo:theory:z:ring:axioms} and~\ref{demo:theory:z:ring:canonical}).
Note that the \coq{Ring_of_Monoid.Axioms} \packager{} is not
a plain record constructor for \coq{Ring_of_Monoid.axioms}, since that
would require more arguments, namely the monoid ones. The
\packager{} synthesized by \HB{} infers them automatically
(as in~\cite[Section 7]{DBLP:conf/itp/MahboubiT13}) thanks to the \coq{hb.canonical}
declaration given just above.

From now on the axioms as well as the abstract theory of rings apply to
integers, as shown in lemma \coq{exercise}.

\subsection{Evolution of the hierarchy}

We now proceed by changing the hierarchy to accommodate the intermediate
structure \coq{AbelianGroup}.

\begin{coqcode}
Elpi hb.declare_mixin Monoid_of_Type A.
  Record axioms := { ... (* unchanged *) ... }.
Elpi hb.end.
Elpi hb.structure Monoid Monoid_of_Type.axioms.

Elpi hb.declare_mixin AbelianGroup_of_Monoid A Monoid.axioms.
  Record axioms := {
    opp : A -> A;
    addrC : commutative (S := A) add;
    addNr : left_inverse zero opp add;
  }.
Elpi hb.end.
Elpi hb.structure AbelianGroup Monoid.axioms AbelianGroup_of_Monoid.axioms.

Elpi hb.declare_mixin Ring_of_AbelianGroup A AbelianGroup.axioms.
  Record axioms := {
    one : A;
    mul : A -> A -> A;
    mulrA : associative mul;
    mul1r : left_id one mul;
    mulr1 : right_id one mul;
    mulrDl : left_distributive mul add;
    mulrDr : right_distributive mul add;
  }.
Elpi hb.end.
Elpi hb.structure Ring Monoid.axioms AbelianGroup.axioms Ring_of_AbelianGroup.axioms.
\end{coqcode}

Some operations and properties were moved from the old \mixin{} for rings
into a newborn \mixin{} \coq{AbelianGroup_of_Monoid} that gathers the
axioms needed to turn a monoid into an Abelian group. Consequently the \mixin{}
for rings is now called \coq{Ring_of_AbelianGroup} (instead of \coq{Ring_of_Monoid})
since it expects the type \coq{A} to be already an Abelian group and hence
gathers fewer axioms.

With this new version of the hierarchy, that we name V2, some code written
for version V1 breaks. For example the simple proof of \coq{addrN} works
but the declaration of the canonical ring over the integers fails, if only
because we don't have a \coq{Ring_of_Monoid.Axioms} \packager{} anymore.

Our objective is to obtain a version of the hierarchy, say V3, that does
not only feature commutative monoids but that is also backward compatible
with V1.

\subsection{The missing puzzle piece}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=\textwidth]{puzzle.pdf}
  \end{center}
  \caption{\label{fig:puzzle}The evolution of the hierarchy. V3 is backward compatible with V1, while V2 is not.}
\end{figure}

The key to make a hierarchy evolve without breaking user code is the full
fledged notion of \emph{\factory{}} \HB{} understands (\mixins{} are degenerate,
hence trivial, factories).

\factories{}, like \mixins{}, are packages for operations and properties but are
not directly used in the definition of structures. Instead a \factory{} is
equipped with \emph{\builder{}s}: user provided pieces of code that extract
from the \factory{} the contents of \mixins{}, so that \packager{}s can be used.

As depicted in figure~\ref{fig:puzzle} we change again the hierarchy
by declaring a \coq{Ring_of_Monoid} \factory{}, that, from the user point of view,
will look indistinguishable from the old \coq{Ring_of_Monoid} \mixin{}
and hence grant backward compatibility between this last version V3 and the
initial one V1.

\begin{coqcode}
Elpi hb.declare_factory Ring_of_Monoid A.
  Record axioms := {
    one : A;
    opp : A -> A;
    mul : A -> A -> A;
    addrC : commutative (add : A -> A ->A);
    addNr : left_inverse zero opp add;
    mulrA : associative mul;
    mul1r : left_id one mul;
    mulr1 : right_id one mul;
    mulrDl : left_distributive mul add;
    mulrDr : right_distributive mul add;
  }.

  Variable f : axioms.                                                          #\label{demo3:variable:f}#

  Definition to_AbelianGroup_of_Monoid :=
    AbelianGroup_of_Monoid.Axioms A (opp f) (addrC f) (addNr f)

  Elpi hb.canonical A to_AbelianGroup_of_Monoid.

  Definition to_Ring_of_AbelianGroup :=
    Ring_of_AbelianGroup.Axioms A (one f) (mul f)
      (mulrA f) (mul1r f) (mulr1 f) (mulrDl f) (mulrDr f).

  Elpi hb.canonical A to_Ring_of_AbelianGroup.

Elpi hb.end.
\end{coqcode}

The record \coq{Ring_of_Monoid.axioms} is the same we declared as a \mixin{}
in version V1. In order to make a \factory{} out of it we equip it with
two definition that embody the \emph{\builder{}s}.
The first is \coq{to_AbelianGroup_of_Monoid} and
explain how to build an \coq{AbelianGroup} structure out of the \factory{}
axioms (named \coq{f}, line~\ref{demo3:variable:f}).
This construction is also registered as canonical for \coq{A},
so that the next construction \coq{to_Ring_of_AbelianGroup} can call
the \coq{Ring_of_AbelianGroup.Axioms} \packager{} that requires \coq{A} to be
an \coq{AbelianGroup}. In this simple example the two \builder{}s are just
partitioning the contents of the \factory{} \coq{f}, but in practice they
often involve proofs that the properties held by the factory
imply the ones held by the \mixins{} characterizing the structures that are
being constructed.

Thanks to this \factory{} we can now declare \coq{Z} to be an instance
of a ring using the \coq{Ring_of_Monoid.Axioms} \packager{}.
The associated \builder{}s generates, behind the scenes, instances of the
\coq{Ring_of_AbelianGroup.axioms} and \coq{AbelianGroup_of_Monoid.axioms} \mixins{}
that in turn are used to build instances of the \coq{AbelianGroup} and \coq{Ring}
structures. Indeed the command \coq{Elpi hb.canonical Z Z_Ring_axioms}
makes \coq{Z} an instance of both structures.
Thanks to that the proof of \coq{example} can use the theory of
both structures, for example \coq{addrN} holds on rings, while \coq{addrA} holds
on Abelian groups. As a result the very same proof works on both
version V1 and V3.

Last, it is worth pointing out that the new factory makes the following
two lines equivalent. In particular the former one, used in V1 to declare
the structure of rings, unfolds to the last one behind the scenes.

\begin{coqcode}
  Elpi hb.structure Ring Monoid.axioms Ring_of_Monoid.axioms.
  Elpi hb.structure Ring Monoid.axioms AbelianGroup.axioms Ring_of_AbelianGroup.axioms.
\end{coqcode}

This is another example of client code that would not break when the hierarchy
moves from V1 to V3: indeed the client of the hierarchy can declare new
structures on top of existing ones as well.

\subsection{\HB{} in a nutshell}

\HB{} provides an indirection so that the client can refer to operations,
properties and packages thereof now matter in where and how they are actually
defined:

\begin{itemize}
\item Operations and properties (axioms) are exported once the first time they
      are used in a structure. The hierarchy designer is free to move them from
      one to another.
\item Structures never disappear but the way they are built may change.
      The hierarchy designer is free to split structures into smaller
      ones in order to better factor and reuse parts of the hierarchy.
\item \packager{}s and \mixins{} never disappear but can change considerably
      in their implementation. A simple \mixin{} can becomes a full fledged
      \factory{} equipped with \builder{}s to ensure retro compatibility.
\item \HB{} high level commands compile into
      the discipline of Packed Classes, that is Coq records, coercions
      and Canonical Structures declarations. This removes a considerable burden
      from the shoulders of the hierarchy designer and the final user.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An abstract presentation of \HB{}}

\subsection{Preliminaries}

\begin{axiom}[\Lang{}, tagret language]\label{def:universe}
  \Lang{} is a set of names denoting terms of an target language.
  The language must feature projections. When
  a projection from $n$ to $m$ exists we write it \proj{n}{m}.
  The identity projection \proj{x}{x} always exists.
\end{axiom}

\begin{axiom}[(\M{}, \depx{}), \mixin{}]\label{def:mixin}
\( \M{} \subseteq \Lang{} \) is the finite set of \mixins{} and
\( \depx \in \M{} \to \powerset\M{} \) is a function expressing
dependencies among \mixins{}.
(\M{}, \depx{}) forms a Directed Acyclig Graph (DAG) and
\depx{} is transitively closed.
If \(m \in \depx{}(n) \) then \( \proj{n}{m} \in \Lang{} \)
\end{axiom}

\begin{definition}[\(\dep \in \powerset{\M{}} \to \powerset\M{}\)]\label{def:depxs}
\(
  \dep{}(M) = \bigcup_{m \in M} \depx (m)
\)
\end{definition}

\begin{definition}[\(\depone{} \in \M{} \to \powerset\M{}\)]\label{def:dep}
\(\depone{}(m) = \dep{}(\{m\})\)
\end{definition}

\begin{axiom}[(\C{}, \cdef{}), \class{}]\label{def:class}
\(\C{} \subseteq \Lang{}\) is the finite set of names for \classes{}.
\(\cdef{} \in \C \to \powerset\M{}\) is a function associating to
each \class{} a set of \mixins{}
such that \(\forall c \in \C{},~ \dep{}(\cdef{}(c)) \subseteq \cdef{}(c)\).
If \(m \in \cdef{}(c) \) then \( \proj{c}{m} \in \Lang{} \).
\cdef{} is injective (no two \classes{} contain the same set of \mixins{}).
\end{axiom}

\begin{axiom}[\Str{}, \structure{}]\label{def:structure}
\(\Str{} \subseteq \Lang{} \) is the finite set of names for \structures{}
and for each \class{} in \C{} there is one and only one \structure{}
in \Str{}.
\end{axiom}\marginpar{frankly, at this level of abstraction I don't see what
structures bring. Can't we talk about structures only when we package (in the
tgt lang?)}

\begin{axiom}[(\F{}, \requires{}, \provides{}, \from{}), \factory{}]\label{def:factory}
  \(\F{} \subseteq \Lang{} \) is the finite set of names for \factories{}.
  It is equipped with the three functions
  \begin{itemize}
    \item\( \requires{} \in \F{} \to \powerset\M{} \)
    \item\( \provides{} \in \F{} \to \powerset\M{} \)
    \item\( \from{} \in \F{} \times \M{} \to \Lang{} \)
  \end{itemize}
  that validate the following properties
  \begin{itemize}
    \item\( \forall f \in \F{},~ \dep{}(\requires{}(f)) \subseteq \requires{}(f)\)
    \item\( \forall f \in \F{},~ \requires{}(f) \cap \provides{}(f) = \emptyset \)
    \item\( \forall f \in \F{},~\exists c \in \C{},~ \cdef{}(c) = \requires{}(f) \cup \provides{}(f) \)
    \item\( \forall f \in \F{},~\exists C \subseteq \C{},~\bigcup_{c\in C}\cdef{}(c) = \requires{}(f)\)
    \item\( \forall f \in \F{},~\forall m \in \provides{}(f),~ \from{}(f,m) \) is defined
  \end{itemize}
\end{axiom}

\begin{proposition}[\( \M{} \subseteq \F{} \)]
  since \(\requires{}(m) = \depone{}(m)\)
  and \(\provides{}(m) = \{m\} \)
  and \(\from{}(m,m) = \proj{m}{m} \)
\end{proposition}

\begin{proposition}[\( \C{} \subseteq \F{} \)]
  since \(\requires{}(c) = \emptyset \)
  and \(\provides{}(c) = \cdef{}(c) \)
  and \(\from{}(c,m) = \proj{c}{m} \)
\end{proposition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The user language of \HB{}}

\begin{abscommand}[hb.declare_mixin] (fs : $\powerset\F{}$) (t : \Lang{}).\\
Declare a term t as a \mixin{}, adding it to \M{}, and defines
\( \dep{}(t) = \bigcup_{f \in fs} \requires{}(f) \).
\end{abscommand}

\begin{abscommand}[hb.declare_factory] (fs : $\powerset\F{}$) (t : \Lang{}) (b : $\powerset\Lang{}$).\\
Declare a term t as a \factory{}, adding it to \F{}, and defines
\begin{itemize}
\item \( \requires{}(t) = \bigcup_{f \in fs} \requires{}(f) \)
\item \( \provides{}(t) = HELP \)
\item \( \from{}(t,m) = b_m \)
\end{itemize}
\end{abscommand}

\begin{abscommand}[hb.declare_structure] (fs : $\powerset\F{}$).\\
crafs a class $c \in \C{}$ where $\cdef{}(c) = HELP$ and its companion $s \in \Str{}$.
\end{abscommand}

\begin{abscommand}[hb.instance] (c : $\Lang{}$) (fs : $\powerset\F{}$).\\
synthesizes terms in $\Lang{}$ corresponding to all the \mixins{} $MS$
that can be build with \from{} and all the \classes{} / \structures{}
for which \( \cdef{}(c) \subseteq MS \).
\end{abscommand}

A few more preliminaries are required in order to implement these signatures.

\subsection{Subclasses and joins}

\begin{definition}[\issubclass{} \(\in \C{}\times\C{}\), \subclass{}]\label{def:subclass}
  \(c1~\issubclass{}~c2\) iff \(\cdef{}(c2) \subseteq \cdef{}(c1)\)
  \end{definition}

\begin{definition}[\(\join{} \in \C{}\times\C{} \to \C{}\)]\label{def:join}
if \(c1, c2 \in \C{}\) and \(\cdef{}(c1) \cap \cdef{}(c2) \neq \emptyset\)
then \(\join{}(c1,c2)\) is the smallest \class{} \(c\) such that
\(\cdef{}(c1) \cup \cdef{}(c2) \subseteq \cdef{}(c)\).
\end{definition}

\begin{remark}[]
\(\join{}(c1,c2)\) is a \subclass{} of both \(c1\) and \(c2\).
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The target language: Coq with Packed, flat, Classes}

The language of packed classes were introduces in
\cite{DBLP:conf/tphol/GarillotGMR09} and used directly to describe the
algebraic hierarchy of the Mathematical Components library.
It is based on a disciplined use of records and projections and
on the possibility of extending the elaborator of Coq
via the declaration of Canonical Structures instances.

\subsection{Describing a structure with record and projections}

\begin{coqcode}
Module S.
  Record mixin A C := {
    one : A;
    op : A -> A -> A;
    opK : forall x, op (op x) = one
  }
  Record axioms A := {
    base : T.axioms A;
    mix  : mixin A base
  }.
  Record type := Pack {
    sort : Type;
    class : axioms sort
  }.
  Module Exports.
    Coercion sort : type >-> Sortclass.
    Definition op {T : type} : T -> T -> T := ...
    Definition one {T:  type} : T := ...
    Definition opK {T:  type} : forall x, op (op x) = one := ...
    Infix "*" := op.
    Infix "1" := one.
  End Exports.
End S.
\end{coqcode}

The module plays the role of a name space.
Export submodule is there because... I don't know.

\subsection{Linking structures and instances via Canonical Structures}

The mechanism of Canonical Structures~\cite{DBLP:conf/itp/MahboubiT13}
lets the user extend the elaborator of the Coq prover. This software component
takes in input a term as written by the user and has to infer all the missing
piece of information that is necessary to make the term well typed.

Example x + y * z

Here + and * come respectively from, but we are mising them, so we have
to find a common type that makes it work. This information comes from
the hierarchy and the links between the structures. The low level mechanism
is the unifier that compares p1 \_ = p2 \_ and has to find a common
superstructure...

The language lets us only write hints of the form p s = v, so we need two
of them here: (p1 s1 = p2 x) and (p1 y = p2 s2) for any x y.

Similarly one can apply an algebraic thoery to an instance (an example)
of a structure. Eg 1 * 2 + 3. The same mechanism of CS let us
extend the unifier to solve p1 \_ = nat.

\subsection{The flatten variant}

Describing a structure by proving a base class and a \mixin{} is very conveniet
if one does it by hand, since it is more concise that spelling out all the
\mixins{} by hand and is also closer to the user language one desires.

Since we are going to synthesize code automatically the have the freedom
to organize \mixins{} as we wish while retaining a compact user language.
We chose to generate classes from scartch, listing all the involved
\mixins{} since this more uniform.

TODO: Example of a by hand flatten class, maybe the one of the join.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compiling \HB{} to Coq with Packed Classes}\label{sec:compilation}

\begin{implementation}[\autoref{def:universe}]
We take the language of Coq as an implementation of \Lang{}.
\end{implementation}

\begin{implementation}[\autoref{def:mixin}]
A \mixin{} \coq{m} \(\in \M{}\) is a Coq record with one of more parameters.
The first parameter must be a \coq{(A : Type)}, while the other parameters are
are \mixins{} applied to \coq{A} and possibly other \mixins{}. E.g.
\begin{coqcode}
Record m3 (A : Type) (p1 : m1 A) (p2 : m2 A p1) := { ... }.
\end{coqcode}
for \coq{m1}, \coq{m2} and \coq{m3} \(\in \M{}\).
Given \(m \in \M{}\), \(\depx{}(m)\) is the set of all
\mixins{} that occur as parameters of \(m\), eg
\depx{}(\coq{m3}) = \{\coq{m2,m1}\} and \depx{}(\coq{m2}) = \{\coq{m1}\}.
\depx{} is transitively closed since records are well typed
in the empty context and describes a DAG since Coq does not
admit circular definitions.
Projections for parameters are trivially defineable.
\end{implementation}

\begin{implementation}[\autoref{def:class}]
A \class{} \coq{c} \(\in \C{}\) is a Coq record with with one parameter
\coq{(A : Type)}. The type of each field is a \mixin{} in \M{} applied to
\coq{A} and, if needed, any number of other fields. E.g.
\begin{coqcode}
Class c (A : Type) := { f1 : m1 A; ...; f3 : m3 A f1 f2; f4 : m2 A }.
\end{coqcode}
\(\cdef{}(c)\) is the set of \mixins{} mentioned in the fields of the \class{},
i.e. \{m1,m2,m3\}.
Given that \class{} records are well typed in the empty context
the set of \mixin{} records is closed transitively.
Projections for parameters are trivially defineable.
The implementation enforces that no two
\class{} records contains the same set of
\mixin{} (disregarding the order of the fields).
\end{implementation}

\begin{implementation}[\autoref{def:structure}]
A \structure{} \coq{s} \(\in \Str{}\) is a Coq record with with no parameters
and two fields. Its first field is \coq{(sort : Type)} and its second field is
\coq{(class : c sort)} for some \coq{c} \(\in \C{}\).
A structure is just a class closed with a sigma type on its parameter, hence
they are in bijection.
\end{implementation}

\begin{implementation}[\autoref{def:factory}]
A \factory{} \coq{f} \(\in \F{}\) is a Coq record with one or more parameters.
The first parameter must be a \coq{(A : Type)}, while the other parameters are
are \factories{} (or \mixins) applied to \coq{A} and possibly other
\factories{} (or \mixins).

MORE
In the packed classes lingo, these are \packager{}s.
\end{implementation}

\begin{command}[hb.declare_mixin M A FS R := { .. } ]
registers in a db R...
\end{command}
\begin{command}[hb.declare_factory M A FS R := {... }. bs hb.end]
we split into two since the bs are hand and can be done interactively.
populates the context with...
the user labels the bs via isntance.
\end{command}
\begin{command}[hb.declare_structure]
declares many records/modules/coercions, for each join... exports operations,
theory submodule....
\end{command}
\begin{command}[hb.instance]
very close to the abstract one, but instruments CS inference with
the synthesizedterms.
\end{command}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The implementation in Coq-Elpi}\label{sec:implementation}

The implementation is based on the Elpi
extension language for Coq. In this section we introduce the features of the
programming language that come handy in the development of \HB{} and
comment a few code snippets.

Coq-Elpi~\cite{CoqElpi} is a Coq plugin embedding
Elpi and providing an
extensive, high level, API to access and script the Coq system at the
vernacular level.
This API lives in the \elpi{coq.} namespace and lets one easily declare
records, coercions, canonical structures, modules, implicit arguments, etc.
The most basic Coq data type exposed to Elpi is the one of references to global
declarations:

\begin{elpicode}
kind gref  type.                 % The data type of references to global terms
type indt  inductive -> gref.    % eg: Coq.Init.Datatypes.nat
type indc  constructor -> gref.  % eg: Coq.Init.Datatypes.O
type const constant -> gref.     % eg: Coq.Init.Peano.plus
\end{elpicode}

The arguments of the three constructors are opaque to Elpi, that can only use
values of these types via dedicated APIs. For example the API for declaring
an inductive type will generate a value of type \elpi{inductive} that
is printed as, for example, \elpi{«nat»}.

Elpi~\cite{DBLP:conf/lpar/DunchevGCT15} is a dialect
of $\lambda$Prolog~\cite{Miller:2012:PHL:2331097}, an higher order
logic programming language that makes it easy to manipulate abstract syntax
tree with binders. Coq-Elpi takes full advantage of this capability by
representing Coq terms in Higher Order Abstract
Syntax~\cite{10.1145/53990.54010} style, reusing the binder of the programming
language in order to represent Coq's ones. Here an excerpt of the data
type of Coq terms:

\begin{elpicode}
kind term type.                              % The data type of Coq terms
type global gref -> term.                    % eg: nat, O, S, plus, ...
type fun    term -> (term -> term) -> term.  % eg: fun x : t => b(x)
type app    list term -> term.               % eg: app [hd|args]
... % all other term constructors are omitted for brevity
\end{elpicode}

Note that the \elpi{fun} constructor holds $\lambda$Prolog function.
In this syntax the Coq term \coq{(fun x : nat => x x)} becomes
\elpi{(fun (global (indt «nat»)) x\ app[x, x])} where \elpi{x\} binds \elpi{x}
in the body of the function. Substitution of a bound variable for a term
can be computed by applying a term (of function type) to an argument.

Data types with binders are also used as input to high level APIs that build
terms behind the scenes. For example a Coq record is just an inductive type
and the API do declare one must allow the type of a field to depend on the
fields that comes before it. Note that the \elpi{field} constructor
takes a coercion flag, the name of the field, its type and binds a term
in the remaining record declaration.

\begin{elpicode}
kind indt-decl type.              % The type of an inductive type declaration
type record      string -> term -> string -> record-decl -> indt-decl.
type field       bool -> string -> term -> (term -> record-decl) -> record-decl.
type end-record  record-decl.
... % constructors for non-record inductive types are omitted for brevity

external pred coq.env.add-indt i:indt-decl, o:inductive.
external pred coq.CS.canonical-projections i:inductive, o:list (option constant).
\end{elpicode}

The \elpi{pred} keyword documents a the types and modes (input or output) of the
arguments of a predicate, while \elpi{external} signals that the
predicate is a builtin (in other words it is implemented in
OCaml rather than $\lambda$Prolog).

We comment these two builtin predicates and the \elpi{indt-decl} type
while looking at the code of \elpi{declare-structure} that is in charge
of scripting the following Coq code (given as a parameter \coq{axioms}):

\begin{coqcode}
Record type : Type := Pack { sort : Type; class : axioms sort }.
\end{coqcode}

The Elpi code builds the declaration, type checks it, adds it to the
Coq environment and returns the projections for the sort and the class
fields (it is handy to have them in the rest of the code).

\begin{elpicode}
pred declare-structure i:factoryname, o:term, o:term, o:term.

declare-structure ClassName Structure SortProjection ClassProjection :- std.do! [
  StructureDeclaration =
    record "type" {{ Type }} "Pack" (
      field ff "sort" {{ Type }} s\                        %\label{binder:sort}%
      field ff "class" (app [global ClassName, s]) _\
    end-record),
  coq.typecheck-indt-decl StructureDeclaration,
  coq.env.add-indt StructureDeclaration StructureName,     %\label{record:decl}%
  coq.CS.canonical-projections StructureName [some SortP, some ClassP],
  Structure = global (indt StructureName),
  SortProjection = global (const SortP),
  ClassProjection = global (const ClassP),
].
\end{elpicode}

Note that the binder \elpi{s\} at line \ref{binder:sort} lets one mention
the first field in the type of the second.
The syntax \elpi{{{ Type }}} is a quotation: it lets
one use the syntax of Coq to write an Elpi expression of type \elpi{term}.
The API \elpi{coq.CS.canonical-projection} lets us find the projections
automatically generated by Coq for a given record.
The last detail worth discussing is that this program makes no use of
backtraking: the \elpi{std.do!} combinator signals that.

In the simple case of the structure record the number of fields, and hence
the number of binders, is fixed. On the contrary the class record has one
field per \mixin{} and each of them can depend on the previous ones.
In order to synthesize terms with binders in an inductive fashion (using
a recursive predicate) $\lambda$Prolog lets one postulate fresh nominal
constants using the \elpi{pi} operator and attach to the
nominal some knowledge in the form of a clause via the \elpi{=>} operator.
This process is called binder mobility: the binder is moved from
the data (that we are building) to the program (the context of the
current computation).
This feature is key to in the following code that synthesizes the
declaration of the fields of the class record.

\begin{elpicode}
pred synthesize-fields.field-for-mixin i:mixinname, o:term.
pred synthesize-fields i:list mixinname, i:term, o:record-decl.

synthesize-fields [] _ Decl :- Decl = end-record.
synthesize-fields [M|ML] T Decl :- std.do! [
  get-mixin-modname M ModName,
  Name is ModName ^ "_mixin",                          %\label{craft:name}%
  dep1 M Deps,                                         %\label{deps:fetch}%
  std.map Deps synthesize-fields.field-for-mixin Args, %\label{deps:satisfy}%
  Type = app[ global M, T | Args ],                    %\label{build:type}%
  Decl = (field ff Name Type f\
          Fields f),
  pi m\                                                %\label{postulate:m}%
    synthesize-fields.field-for-mixin M m =>           %\label{postulate:satisfy}%
    synthesize-fields ML T (Fields m)                  %\label{rec:call}%
].
\end{elpicode}

The first predicate \elpi{synthesize-fields.field-for-mixin} is used
to link a \mixin{} to a nominal that corresponds to the record field
for that mixin. It has no clauses in the base program but some clauses
are added dynamically by \elpi{synthesize-fields}.

The second predicate proceeds by recursion on the (topologically sorted) list of \mixins{},
and terminates when the list is empty. If the list contains a \mixin{} \elpi{M}
then it crafts a name for it \elpi{Name} (line~\ref{craft:name}),
fetches its dependencies (line~\ref{deps:fetch}) and
finds the (previous declared) record fields holding these \mixins{}
(line~\ref{deps:satisfy}).
The \elpi{(std.map L1 P L2)} predicate relates the two lists \elpi{L1} and
\elpi{L2} point wise using the predicate \elpi{P}.

Line~\ref{build:type} builds the type of the field: the \mixin{} name applied
to the type (sort) and all its dependencies.
Note that the \elpi{Fields} variable, representing the declaration of the
next fields, is under the binder for \elpi{f} (the current field).
In order to make the recursive call under that binder (line~\ref{rec:call})
and recursively process \elpi{ML} we postulate a nominal
\elpi{m} (line~\ref{postulate:m}) that is a term satisfying any
future dependency on the current \mixin{} (line~\ref{postulate:satisfy})
and we replace \elpi{f} by \elpi{m} in \elpi{Fields} by writing
\elpi{(Fields m)}.

The code of \elpi{synthesize-fields} makes an idiomatic use
of \elpi{=>} in $\lambda$Prolog: the current program is temporarily
extended with a clause.

\marginpar{this may go}The same operation, but with a persistent
effect, is made available by Coq-Elpi via a dedicated API to extend
data bases. A data base is a named set of clauses and
commands are typically built by accumulating specific clauses on top
of a data base. Here an excerpt of the \verb+hierarchy.db+ data base and
of the \elpi{declare_mixin} command. Text between \verb+lp:{{+ and \verb+}}+
is Elpi code embedded in a Coq file. All the vernacular commands beginning
with \coq{Elpi} are provided by the Coq-Elpi plugin.

\begin{coqcode}
Elpi Db hierarchy.db lp:{{
  pred dep1 o:mixinname, o:list mixinname.
  ... % for brevity we omit class and join
}}.
Elpi Command declare_mixin.
Elpi Accumulate Db hierarchy.db.
Elpi Accumulate lp:{{
  main [str S] :- !, std.do! [
    coq.locate S M,
    coq.env.typeof M Ty,
    gather-mixin-dendencies Ty [] ML, % implementation omitted for brevity
    coq.elpi.accumulate "hierarchy.db" (clause _ _ (dep1 M ML)),
    ...
  ].
  main _ :- coq.error "Usage: declare_mixin <mixin>".
}}.
\end{coqcode}

Line 11 computes the dependencies of \mixin{} \elpi{M} given
its type and line 12 crafs a clause for \elpi{dep1} and
adds it to the data base \elpi{"hierarchy.db"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Benchmark}
%if we can port ssralg, or not... It would be nice, but maybe its a bit late.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}
The closest work is the one about Packed Classes~\cite{DBLP:conf/tphol/GarillotGMR09} on which we
build. The main differences are that \HB{} is a higher level language
that is compiled down to Flat Packed Classes. The systematic use of
\factories{} makes the user interface of a hierarchy stable under the insertion of
intermediate structures in the hierarchy, a property that Packed Classes lacks.
Finally many of the intricacy of Packed Classes are hidden to the user by
the compilation step, making the language less error prone.
\marginpar{ET: I guess you have more to say here}

In~\cite{CaretteCombinators} Carette and O'Connor describe the language of
Theory Presentation Combinators that can be used to describe a hierarchy of
algebraic structures.
They focus on the categorical semantics of the language that is built upon
the category of context.
They don't describe any actual compilation to the language of a mainstream
interactive prover, indeed they claim their language to be mostly type theory
independent. We know they considered targeting type theory and the language
of unification hints~\cite{10.1007/978-3-642-03359-9_8}
(a super set of the one of Canonical Structures),
but we could not find any written trace of that. Language wise they provides
keywords such as \verb+combine+ and \verb+over+ to share (reuse) a property
when defining a new structure. For example in order to avoid restating
the commutativity property when defining Abelian groups they combine
a commutative monoid and a group forcing the subjacent monoid to coincide:
\begin{verbatim}
CommutativeGroup := combine CommutativeMonoid , Group over Monoid
\end{verbatim}
In our language \HB{} the same role is played by \emph{\mixins{}}.
A \mixin{} lets one write once and forall a property and abstract it over types
and operations so that it can be reused in all the structures that need it.
\marginpar{cyril fix this sentence}

The MMT system~\cite{RABE20131} provides a framework to describe formal
languages in a logical framework, providing good support for binders and
notations. It also provides an expressive module system to organize
theories and express relations among them in the form of functors.
At the time of writing
it provides limited support for elaborating user input taking systematic
advantage of the contents of the theories. The elaborator can be extended
by the user writing Scala code, and in principle use the contents of the
libraries to make sense of an incomplete expressions, but no higher level
language or mechanism is provided.

The library of the Mizar system features a hierarchy of algebraic
structures~\cite{7733265}. In spite of lacking dependent types, Mizar
provides the concept of attributed types and adjectives
that can be used to describe he signature of structures as one would
do with a dependently typed record and their properties as
one would define a conjunctive predicate.
The Mizar language also provides the notation of cluster that is used
to link structures: by showing that property $P$ implies property $Q$
one can inform automation that structures characterized by $P$ are
instances of structures characterized by $Q$. The foundational theory of Mizar
is characterized by an extensional notion of equality that makes it easy
to share the signature or the properties of structures by just requiring
a proof of their equivalence that is in turn used by automation to treat
equivalent structures as equal.

\marginpar{
the word \factory{} comes from "the gang of four" design patterns, we
could cite it. Cyril sees a similarity between the AbstractFactory design
pattern and our notion of factory.
}

\subsection{Other target languages}

We could have chosen telescopes~\cite{telescopes} or unbundled
classes~\cite{mathclasses} as the target language for \HB{}.
We believe it would take only a minor effort to patch \coq{hierarchy-builder}
in order to represent structures in these ways.

At the same time the Mathematical Components library, given the size and
the depth of the hierarchy, adopts Packed Classes because they offer a good
compromise between flexibility and performance, and is our objective to
adopt \HB{} in that context as soon as possible. At the same time one
can imagine a future were the Coq system will provide competitive
performances on unbundled classes.
It is a virtue of our work to provide a user language that is separate
from the implementation one, so we could in principle target any other
equally expressive language without the user noticing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
In this paper we design and implement \HB{}, a high level language to describe
hierarchies of algebraic structures. The implementation of \HB{} is
based on the Elpi extension language for the Coq system and is available
at \url{https://github.com/math-comp/hierarchy-builder}.

The high level language is only loosely tied to Coq or even Type Theory.
It could probably be adopt without major changes in other tools. Indeed the
properties and invariants that link \factories{}, \mixins{} and \classes{}
are key to rule out meaningless or ambiguous sentences and are not
specific to the logic setting on which a prover stands.

The compilation scheme we present in \autoref{sec:compilation} is of
course tied to dependent records
and Canonical Structures, features that are available in Coq but also
in other provers based on Type Theory such a Matita~\cite{DBLP:conf/cade/AspertiRCT11}
and Lean~\cite{DBLP:conf/cade/MouraKADR15}
that provide Unification Hints~\cite{10.1007/978-3-642-03359-9_8}, a strict
super language of Canonical Structures.

We leave to future work extending \HB{} to support structures parametrized
by structures such as the one of module over a ring.
We also leave to future
work the automatic synthesis of the notion of morphism between structures
of the hierarchy.

%The implementation presented in section \ref{sec:implementation} is tied
%to the Coq-Elpi plugin, which provides both the Elpi language and a comprehensive
%set of APIs. While the APIs are tied to Coq, the Elpi programming language
%comes as an OCaml library and could, in principle, be linked to other provers.

\bibliography{biblio}

\appendix

\section{Coq reference}

\begin{coqcode}
Section OperationProperties.
Variable T : Type.
Variable e : T.
Variable inv : T -> T.
Variable op : T -> T -> T.
Variable add : T -> T -> T.

Definition left_id  := forall x, op e x = x.
Definition right_id := forall x, op x e = x.

Definition left_inverse := forall x, op (inv x) x = e.

Definition commutative := forall x y, op x y = op y x.
Definition associative := forall x y z, op x (op y z) = op (op x y) z.

Definition left_distributive  := forall x y z, op (add x y) z = add (op x z) (op y z).
Definition right_distributive := forall x y z, op x (add y z) = add (op x y) (op x z).
\end{coqcode}

\end{document}



\section{Typesetting instructions -- Summary}
\label{sec:typesetting-summary}

LIPIcs is a series of open access high-quality conference proceedings across all fields in informatics established in cooperation with Schloss Dagstuhl. 
In order to do justice to the high scientific quality of the conferences that publish their proceedings in the LIPIcs series, which is ensured by the thorough review process of the respective events, we believe that LIPIcs proceedings must have an attractive and consistent layout matching the standard of the series.
Moreover, the quality of the metadata, the typesetting and the layout must also meet the requirements of other external parties such as indexing service, DOI registry, funding agencies, among others. The guidelines contained in this document serve as the baseline for the authors, editors, and the publisher to create documents that meet as many different requirements as possible. 

Please comply with the following instructions when preparing your article for a LIPIcs proceedings volume. 
\paragraph*{Minimum requirements}

\begin{itemize}
\item Use pdflatex and an up-to-date \LaTeX{} system.
\item Use further \LaTeX{} packages and custom made macros carefully and only if required.
\item Use the provided sectioning macros: \verb+\section+, \verb+\subsection+, \verb+\subsubsection+, \linebreak \verb+\paragraph+, \verb+\paragraph*+, and \verb+\subparagraph*+.
\item Provide suitable graphics of at least 300dpi (preferably in PDF format).
\item Use BibTeX and keep the standard style (\verb+plainurl+) for the bibliography.
\item Please try to keep the warnings log as small as possible. Avoid overfull \verb+\hboxes+ and any kind of warnings/errors with the referenced BibTeX entries.
\item Use a spellchecker to correct typos.
\end{itemize}

\paragraph*{Mandatory metadata macros}
Please set the values of the metadata macros carefully since the information parsed from these macros will be passed to publication servers, catalogues and search engines.
Avoid placing macros inside the metadata macros. The following metadata macros/environments are mandatory:
\begin{itemize}
\item \verb+\title+ and, in case of long titles, \verb+\titlerunning+.
\item \verb+\author+, one for each author, even if two or more authors have the same affiliation.
\item \verb+\authorrunning+ and \verb+\Copyright+ (concatenated author names)\\
The \verb+\author+ macros and the \verb+\Copyright+ macro should contain full author names (especially with regard to the first name), while \verb+\authorrunning+ should contain abbreviated first names.
\item \verb+\ccsdesc+ (ACM classification, see \url{https://www.acm.org/publications/class-2012}).
\item \verb+\keywords+ (a comma-separated list of keywords).
\item \verb+\relatedversion+ (if there is a related version, typically the ``full version''); please make sure to provide a persistent URL, e.\,g., at arXiv.
\item \verb+\begin{abstract}...\end{abstract}+ .
\end{itemize}

\paragraph*{Please do not \ldots} %Do not override the \texttt{\seriesstyle}-defaults}
Generally speaking, please do not override the \texttt{lipics-v2019}-style defaults. To be more specific, a short checklist also used by Dagstuhl Publishing during the final typesetting is given below.
In case of \textbf{non-compliance} with these rules Dagstuhl Publishing will remove the corresponding parts of \LaTeX{} code and \textbf{replace it with the \texttt{lipics-v2019} defaults}. In serious cases, we may reject the LaTeX-source and expect the corresponding author to revise the relevant parts.
\begin{itemize}
\item Do not use a different main font. (For example, the \texttt{times} package is forbidden.)
\item Do not alter the spacing of the \texttt{lipics-v2019.cls} style file.
\item Do not use \verb+enumitem+ and \verb+paralist+. (The \texttt{enumerate} package is preloaded, so you can use
 \verb+\begin{enumerate}[(a)]+ or the like.)
\item Do not use ``self-made'' sectioning commands (e.\,g., \verb+\noindent{\bf My+ \verb+Paragraph}+).
\item Do not hide large text blocks using comments or \verb+\iffalse+ $\ldots$ \verb+\fi+ constructions. 
\item Do not use conditional structures to include/exclude content. Instead, please provide only the content that should be published -- in one file -- and nothing else.
\item Do not wrap figures and tables with text. In particular, the package \texttt{wrapfig} is not supported.
\item Do not change the bibliography style. In particular, do not use author-year citations. (The
\texttt{natbib} package is not supported.)
\end{itemize}

\enlargethispage{\baselineskip}

This is only a summary containing the most relevant details. Please read the complete document ``LIPIcs: Instructions for Authors and the \texttt{lipics-v2019} Class'' for all details and don't hesitate to contact Dagstuhl Publishing (\url{mailto:publishing@dagstuhl.de}) in case of questions or comments:
\href{http://drops.dagstuhl.de/styles/lipics-v2019/lipics-v2019-authors/lipics-v2019-authors-guidelines.pdf}{\texttt{http://drops.dagstuhl.de/styles/lipics-v2019/\newline lipics-v2019-authors/lipics-v2019-authors-guidelines.pdf}}

\section{Lorem ipsum dolor sit amet}

Lorem ipsum dolor sit amet, consectetur adipiscing elit \cite{DBLP:journals/cacm/Knuth74}. Praesent convallis orci arcu, eu mollis dolor. Aliquam eleifend suscipit lacinia. Maecenas quam mi, porta ut lacinia sed, convallis ac dui. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse potenti. Donec eget odio et magna ullamcorper vehicula ut vitae libero. Maecenas lectus nulla, auctor nec varius ac, ultricies et turpis. Pellentesque id ante erat. In hac habitasse platea dictumst. Curabitur a scelerisque odio. Pellentesque elit risus, posuere quis elementum at, pellentesque ut diam. Quisque aliquam libero id mi imperdiet quis convallis turpis eleifend. 

\begin{lemma}[Lorem ipsum]
\label{lemma:lorem}
Vestibulum sodales dolor et dui cursus iaculis. Nullam ullamcorper purus vel turpis lobortis eu tempus lorem semper. Proin facilisis gravida rutrum. Etiam sed sollicitudin lorem. Proin pellentesque risus at elit hendrerit pharetra. Integer at turpis varius libero rhoncus fermentum vitae vitae metus.
\end{lemma}

\begin{proof}
Cras purus lorem, pulvinar et fermentum sagittis, suscipit quis magna.

\begin{claim}
content...
\end{claim}
\begin{claimproof}
content...
\end{claimproof}

\end{proof}

\begin{corollary}[Curabitur pulvinar, \cite{DBLP:books/mk/GrayR93}]
\label{lemma:curabitur}
Nam liber tempor cum soluta nobis eleifend option congue nihil imperdiet doming id quod mazim placerat facer possim assum. Lorem ipsum dolor sit amet, consectetuer adipiscing elit, sed diam nonummy nibh euismod tincidunt ut laoreet dolore magna aliquam erat volutpat.
\end{corollary}

\begin{proposition}\label{prop1}
This is a proposition
\end{proposition}

\autoref{prop1} and \cref{prop1} \ldots

\subsection{Curabitur dictum felis id sapien}

Curabitur dictum \cref{lemma:curabitur} felis id sapien \autoref{lemma:curabitur} mollis ut venenatis tortor feugiat. Curabitur sed velit diam. Integer aliquam, nunc ac egestas lacinia, nibh est vehicula nibh, ac auctor velit tellus non arcu. Vestibulum lacinia ipsum vitae nisi ultrices eget gravida turpis laoreet. Duis rutrum dapibus ornare. Nulla vehicula vulputate iaculis. Proin a consequat neque. Donec ut rutrum urna. Morbi scelerisque turpis sed elit sagittis eu scelerisque quam condimentum. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Aenean nec faucibus leo. Cras ut nisl odio, non tincidunt lorem. Integer purus ligula, venenatis et convallis lacinia, scelerisque at erat. Fusce risus libero, convallis at fermentum in, dignissim sed sem. Ut dapibus orci vitae nisl viverra nec adipiscing tortor condimentum \cite{DBLP:journals/cacm/Dijkstra68a}. Donec non suscipit lorem. Nam sit amet enim vitae nisl accumsan pretium. 

\begin{lstlisting}[caption={Useless code},label=list:8-6,captionpos=t,float,abovecaptionskip=-\medskipamount]
for i:=maxint to 0 do 
begin 
    j:=square(root(i));
end;
\end{lstlisting}

\subsection{Proin ac fermentum augue}

Proin ac fermentum augue. Nullam bibendum enim sollicitudin tellus egestas lacinia euismod orci mollis. Nulla facilisi. Vivamus volutpat venenatis sapien, vitae feugiat arcu fringilla ac. Mauris sapien tortor, sagittis eget auctor at, vulputate pharetra magna. Sed congue, dui nec vulputate convallis, sem nunc adipiscing dui, vel venenatis mauris sem in dui. Praesent a pretium quam. Mauris non mauris sit amet eros rutrum aliquam id ut sapien. Nulla aliquet fringilla sagittis. Pellentesque eu metus posuere nunc tincidunt dignissim in tempor dolor. Nulla cursus aliquet enim. Cras sapien risus, accumsan eu cursus ut, commodo vel velit. Praesent aliquet consectetur ligula, vitae iaculis ligula interdum vel. Integer faucibus faucibus felis. 

\begin{itemize}
\item Ut vitae diam augue. 
\item Integer lacus ante, pellentesque sed sollicitudin et, pulvinar adipiscing sem. 
\item Maecenas facilisis, leo quis tincidunt egestas, magna ipsum condimentum orci, vitae facilisis nibh turpis et elit. 
\end{itemize}

\begin{remark}
content...
\end{remark}

\section{Pellentesque quis tortor}

Nec urna malesuada sollicitudin. Nulla facilisi. Vivamus aliquam tempus ligula eget ornare. Praesent eget magna ut turpis mattis cursus. Aliquam vel condimentum orci. Nunc congue, libero in gravida convallis \cite{DBLP:conf/focs/HopcroftPV75}, orci nibh sodales quam, id egestas felis mi nec nisi. Suspendisse tincidunt, est ac vestibulum posuere, justo odio bibendum urna, rutrum bibendum dolor sem nec tellus. 

\begin{lemma} [Quisque blandit tempus nunc]
Sed interdum nisl pretium non. Mauris sodales consequat risus vel consectetur. Aliquam erat volutpat. Nunc sed sapien ligula. Proin faucibus sapien luctus nisl feugiat convallis faucibus elit cursus. Nunc vestibulum nunc ac massa pretium pharetra. Nulla facilisis turpis id augue venenatis blandit. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus.
\end{lemma}

Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.

\appendix
\section{Morbi eros magna}

Morbi eros magna, vestibulum non posuere non, porta eu quam. Maecenas vitae orci risus, eget imperdiet mauris. Donec massa mauris, pellentesque vel lobortis eu, molestie ac turpis. Sed condimentum convallis dolor, a dignissim est ultrices eu. Donec consectetur volutpat eros, et ornare dui ultricies id. Vivamus eu augue eget dolor euismod ultrices et sit amet nisi. Vivamus malesuada leo ac leo ullamcorper tempor. Donec justo mi, tempor vitae aliquet non, faucibus eu lacus. Donec dictum gravida neque, non porta turpis imperdiet eget. Curabitur quis euismod ligula. 


%%
%% Bibliography
%%

%% Please use bibtex, 

\bibliography{biblio}

\appendix

\section{Styles of lists, enumerations, and descriptions}\label{sec:itemStyles}

List of different predefined enumeration styles:

\begin{itemize}
\item \verb|\begin{itemize}...\end{itemize}|
\item \dots
\item \dots
%\item \dots
\end{itemize}

\begin{enumerate}
\item \verb|\begin{enumerate}...\end{enumerate}|
\item \dots
\item \dots
%\item \dots
\end{enumerate}

\begin{alphaenumerate}
\item \verb|\begin{alphaenumerate}...\end{alphaenumerate}|
\item \dots
\item \dots
%\item \dots
\end{alphaenumerate}

\begin{romanenumerate}
\item \verb|\begin{romanenumerate}...\end{romanenumerate}|
\item \dots
\item \dots
%\item \dots
\end{romanenumerate}

\begin{bracketenumerate}
\item \verb|\begin{bracketenumerate}...\end{bracketenumerate}|
\item \dots
\item \dots
%\item \dots
\end{bracketenumerate}

\begin{description}
\item[Description 1] \verb|\begin{description} \item[Description 1]  ...\end{description}|
\item[Description 2] Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\item[Description 3]  \dots
%\item \dots
\end{description}

\section{Theorem-like environments}\label{sec:theorem-environments}

List of different predefined enumeration styles:

\begin{theorem}\label{testenv-theorem}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{theorem}

\begin{lemma}\label{testenv-lemma}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{lemma}

\begin{corollary}\label{testenv-corollary}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{corollary}

\begin{proposition}\label{testenv-proposition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proposition}

\begin{exercise}\label{testenv-exercise}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{exercise}

\begin{definition}\label{testenv-definition}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{definition}

\begin{example}\label{testenv-example}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{example}

\begin{note}\label{testenv-note}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note}

\begin{note*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{note*}

\begin{remark}\label{testenv-remark}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark}

\begin{remark*}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{remark*}

\begin{claim}\label{testenv-claim}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim}

\begin{claim*}\label{testenv-claim2}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claim*}

\begin{proof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{proof}

\begin{claimproof}
Fusce eu leo nisi. Cras eget orci neque, eleifend dapibus felis. Duis et leo dui. Nam vulputate, velit et laoreet porttitor, quam arcu facilisis dui, sed malesuada risus massa sit amet neque.
\end{claimproof}

