
\documentclass[a4paper,UKenglish,cleveref, autoref]{lipics-v2019}
\usepackage{hyperref}
\usepackage{minted} % pip3 install pygments, pdflatex -shell-escape hb
\newminted[elpicode]{elpi.py:ElpiLexer -x}{linenos=true,fontsize=\footnotesize,escapeinside=\%\%}
\newmintinline[elpi]{elpi.py:ElpiLexer -x}{fontsize=\small}
\newminted[coqcode]{elpi.py:CoqElpiLexer -x}{linenos=true,fontsize=\footnotesize,mathescape,escapeinside=\#\#}
\newmintinline[coq]{elpi.py:CoqElpiLexer -x}{fontsize=\small}
\usepackage{xcolor}

\definecolor{dkgreen}{rgb}{0.0, 0.5, 0.0}

\newcommand{\coqelpi}{Coq-Elpi}
\newcommand{\HB}{\ensuremath{\mathcal{HB}}}
\newcommand{\hb}{\coq{hierarchy-builder}}

%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling cleveref support, use "autoref"


%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Hierarchy Builder: algebraic~hierarchies made easy in Coq with Elpi} %TODO Please add

\titlerunning{Hierarchy Builder}%optional, please use if title is longer than one line

\author{Cyril Cohen}{Inria, France}{Cyril.Cohen@inria.fr}{}{}
\author{Kazuhiko Sakaguchi}{University of Tsukuba, Japan}{sakaguchi@logic.cs.tsukuba.ac.jp}{}{}
\author{Enrico Tassi}{Inria, France}{Enrico.Tassi@inria.fr}{}{}
\authorrunning{C.\,Cohen and K.\,Sakaguchi and E.\,Tassi}
% \author{John Q. Public}{Dummy University Computing Laboratory, [optional: Address], Country \and My second affiliation, Country \and \url{http://www.myhomepage.edu} }{johnqpublic@dummyuni.org}{https://orcid.org/0000-0002-1825-0097}{(Optional) author-specific funding acknowledgements}%TODO mandatory, please use full name; only 1 author per \author macro; first two parameters are mandatory, other parameters can be empty. Please provide at least the name of the affiliation and the country. The full address is optional
% \author{Joan R. Public\footnote{Optional footnote, e.g. to mark corresponding author}}{Department of Informatics, Dummy College, [optional: Address], Country}{joanrpublic@dummycollege.org}{[orcid]}{[funding]}
% \authorrunning{J.\,Q. Public and J.\,R. Public}%TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Cyril Cohen and Kazuhiko Sakaguchi and Enrico Tassi}%TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[100]{General and reference~General literature}
\ccsdesc[100]{General and reference}%TODO mandatory: Please choose ACM 2012 classifications from https://dl.acm.org/ccs/ccs_flat.cfm 
\supplement{Source code of the Coq package: \url{https://github.com/math-comp/hierarchy-builder}}
\keywords{Algebraic Hierarchy, Packed Classes, Coq, Elpi, Metaprogramming, $\lambda$Prolog}%TODO mandatory; please add comma-separated list of keywords

\category{}%optional, e.g. invited paper

\relatedversion{}%optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversion{A full version of the paper is available at \url{...}.}

\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

%\nolinenumbers %uncomment to disable line numbering

%\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% TODO: Write glossary
% remove distinction
% TODO: Structure -> Class
% TODO: packager -> ClassBuilder
% TODO: Builder -> Builder
% Factories ( primitive / general ) ; kill mixin

\newcommand{\Lang}{\ensuremath{\Lambda}}
\newcommand{\term}{term}
\newcommand{\mixin}{mixin}
\newcommand{\mixins}{mixins}
\newcommand{\Mixins}{Mixins}
\newcommand{\M}{\ensuremath{\mathcal{M}}}
\newcommand{\factory}{factory}
\newcommand{\factories}{factories}
\newcommand{\Factories}{Factories}
\newcommand{\packager}{packager}
\newcommand{\packagers}{packagers}
\newcommand{\Packager}{Packager}
\newcommand{\builder}{builder}
\newcommand{\mixinbuilder}{builder}
\newcommand{\mixinbuilders}{builders}
\newcommand{\factoryinstance}{factory instance}
\newcommand{\factoryinstances}{factory instances}
\newcommand{\F}{\ensuremath{\mathcal{F}}}
\newcommand{\dep}{\ensuremath{dep}}
\newcommand{\depone}{\ensuremath{dep_1}}
\newcommand{\powerset}[1]{\raisebox{.15\baselineskip}{\Large\ensuremath{\wp}}(#1)}
\newcommand{\C}{\ensuremath{\mathcal{C}}}
\newcommand{\B}{\ensuremath{\mathcal{B}}}
\newcommand{\FP}{\ensuremath{\mathcal{FP}}}
\newcommand{\class}{class}
\newcommand{\classes}{classes}
\newcommand{\cdef}{\ensuremath{def}}
\newcommand{\Str}{\ensuremath{\mathcal{S}}}
\newcommand{\structure}{structure}
\newcommand{\structures}{structures}
\newcommand{\issubclass}{\ensuremath{sub}}
\newcommand{\subclass}{subclass}
\newcommand{\join}{\ensuremath{join}}
\newcommand{\requires}{\ensuremath{requires}}
\newcommand{\target}{\ensuremath{target}}
\newcommand{\provides}{\ensuremath{provides}}
\newcommand{\from}{\ensuremath{\mathsf{from}}}
\newcommand{\proj}[2]{\ensuremath{#1[#2]}}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\enum}[2]{\ensuremath{\set{#1,\ldots,#2}}}
\newcommand{\vect}[1]{\overrightarrow{#1}}
\newcommand{\pmp}[1]{\ensuremath{\vect{\left(p : m\ T\ p_\sigma\right)}^{#1}}}
\newcommand{\hbmixin}{{\tt\color{dkgreen}Elpi hb.mixin}}
\newcommand{\hbfactory}{{\tt\color{dkgreen}Elpi hb.factory}}
\newcommand{\hbinstance}{{\tt\color{dkgreen}Elpi hb.instance}}
\newcommand{\hbstructure}{{\tt\color{dkgreen}Elpi hb.structure}}

\newtheoremstyle{implem}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1}\thmnumber{ #2}\thmnote{ #3}}

\theoremstyle{implem}
\newtheorem*{implementation}{Implementation of}

\theoremstyle{implem}
\newtheorem*{invariant}{Programming invariant for}

\newtheoremstyle{command}{\topsep}{\topsep}{}{0pt}{\sffamily\bfseries}{ }{5pt plus 1pt minus 1pt}%
{$\blacktriangleright$ \thmname{#1} {\coq{#3}}}
\theoremstyle{command}
\newtheorem*{command}{Coq command}

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}
It is nowadays customary to organize libraries of machine checked
proofs around hierarchies of algebraic
structures~\cite{10.1145/3372885.3373824,mathclasses,DBLP:journals/mics/BoldoLM15,DBLP:conf/mpc/AffeldtNS19}.
One influential example is the Mathematical Components library on top
of which the long and intricate proof of the Odd Order
Theorem could be fully formalized~\cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13}.

Still, building algebraic hierarchies in a proof assistant such as Coq~\cite{Coq:manual}
requires a lot of manual labor and often a deep expertise in the internals of
the prover~\cite{DBLP:conf/tphol/GarillotGMR09,DBLP:conf/itp/MahboubiT13}.
Moreover, according to our experience~\cite{KSdraft},
making a hierarchy evolve without causing breakage in client code equally tricky:
Even a simple refactoring such as splitting a structure into two simpler ones
is hard to get right.

In this paper we describe \HB{}, a high level language
to \emph{build} hierarchies of algebraic structures and to make these hierarchies
\emph{evolve} without breaking user code. The key concepts are the ones of
\emph{\factory{}} and \emph{\packager{}} that lets the hierarchy developer
describe an actual
interface for their library. Behind that interface the developer can provide
appropriate code to ensure retro compatibility.
We implement the \HB{} language in the \hb{} addon for the Coq
system using the Elpi~\cite{DBLP:conf/lpar/DunchevGCT15,CoqElpi}
extension language.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

Modern libraries of machine checked proofs are organized around
hierarchies of algebraic structures~\cite{10.1145/3372885.3373824,mathclasses,DBLP:journals/mics/BoldoLM15,DBLP:conf/mpc/AffeldtNS19}.
For example the Mathematical Components library for the Coq system~\cite{Coq:manual}
provides a very rich, ever growing, hierarchy of structures such as
group, ring, module, algebra, field, partial order, order, lattice\ldots
The hierarchy does not only serve the purpose of organizing knowledge, but
also to make it easy to exploit it. Indeed the interactive prover can
take advantage of the structure of the library and the relation between
its concepts to infer part of information usually left implicit
by the user, a capability that turned out to be key to tame
the complexity and size of the formal proof of the Odd Order
Theorem~\cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13}.

The hierarchy of the Mathematical Components library
is implemented following the discipline of Packed Classes initially introduced
in \cite{DBLP:conf/itp/GonthierAABCGRMOBPRSTT13} and later also adopted in
\cite{DBLP:conf/mpc/AffeldtNS19} and \cite{DBLP:journals/mics/BoldoLM15}.
We call Packed Classes a discipline, and not a language, because, in spite of
its many virtues, it is unwieldy to use. In particular it leaks to the user
many of the technical details of the Coq system. As a result, one
needs to be a Coq expert in order to build or modify a hierarchy, and even
experts make mistakes when doing that as shown in~\cite{KSdraft}.
Another inconvenience of the Packed Classes discipline is that even
simple changes to the hierarchy, such as splitting a structure into
two simpler ones, break user code.

In this paper we describe \HB{}, a high level language
to \emph{build} hierarchies of algebraic structures and to make these hierarchies
\emph{evolve} without breaking user code. The key concepts are the ones of
\emph{\factory{}} and \emph{\packager{}} that let the hierarchy developer describe an actual
interface for their library. Behind that interface the developer can provide
appropriate code to ensure retro compatibility.
We implement the \HB{} language by compiling it
to a variant of the Packed Classes discipline, that we call \emph{flat},
in the \hb{} addon for Coq. We write this addon using using the
Elpi~\cite{DBLP:conf/lpar/DunchevGCT15,CoqElpi} extension language.\\

\noindent To sum up, the main contributions of the paper are:
\begin{itemize}
\item the design of the \HB{} language
\item the compilation of \HB{} to the (flat) Packed Classes discipline
\item the implementation of \HB{} in the \hb{} addon for Coq
\end{itemize}
The paper is organized as follows. Via an example we introduce
\HB{} and its key ideas. %We then provide a formal description of \HB{}.
We then describe the discipline
of Packed Classes and we show how \HB{} can be compiled to it.
We then discuss the implementation of the Coq addon via the Elpi extension
language and we position \HB{} in the literature.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
\section{\HB{} by examples: building and evolving a hierarchy}
\label{sec:example}

The first version of our hierarchy (that we name V1) features only two
structures: \coq{Monoid} and \coq{Ring}.
\marginpar{remove hb.end for mixins, use next release of coq elpi}
\begin{coqcode}
#\hbmixin{}# Monoid_of_Type A.                       #\label{demo:mixin:mot}#
  Record axioms := {
    zero : A;
    add : A -> A -> A;
    addrA : associative add;             (* `add` is associative.                   *)
    add0r : left_id zero add;            (* `zero` is the left and right absorbing  *)
    addr0 : right_id zero add;           (*   element with respect to `add`.        *)
  }.
Elpi hb.end.                                              #\label{demo:mixin:mot:end}#
#\hbstructure{}# Monoid Monoid_of_Type.axioms.        #\label{demo:structure:monoid}#

#\hbmixin{}# Ring_of_Monoid A Monoid.axioms.       #\label{demo:mixin:rom}#
  Record axioms := {
    one : A;
    opp : A -> A;
    mul : A -> A -> A;
    addNr : left_inverse zero opp add;   (* `opp x` is the left and right additive  *)
    addrN : right_inverse zero opp add;  (*   inverse of `x`.                       *)
    mulrA : associative mul;             (* `mul` is associative.                   *)
    mul1r : left_id one mul;             (* `one` is the left and right identity    *)
    mulr1 : right_id one mul;            (*   element with respect to `mul`.        *)
    mulrDl : left_distributive mul add;  (* `mul` is left and right distributive    *)
    mulrDr : right_distributive mul add; (*   over `add`.                           *)
  }.
Elpi hb.end.
#\hbstructure{}# Ring Monoid.axioms Ring_of_Monoid.axioms. #\label{demo:structure:ring}#

\end{coqcode}

In order to build a structure we need to declare some \factories{} and
later assemble them. One kind of \factory{} supported by \HB{}, the simplest
one, is called \emph{\mixin{}} and is embodied by a record, by convention named
\coq{axioms}, that gathers operations and properties.

\Mixins{} are declared via the \coq{#\hbmixin{}#} command
that takes a module name,
a type variable name and a possibly empty list of \factories{} for that type.
The code between lines~\ref{demo:mixin:mot}
and~\ref{demo:mixin:mot:end} declares a \mixin{} that can turn a naked
type \coq{A} into a monoid, hence we chose the module name to be \coq{Monoid_of_Type}.

The \coq{#\hbstructure{}#} command takes in input a name S and a possibly
empty list of \factories{}
It registers a structure S in the hierarchy placing
any definition specific to that structure inside a Coq module named \coq{S}.
Line~\ref{demo:structure:monoid} hence forges a the structure \coq{Monoid}.

Line~\ref{demo:mixin:rom} declares a second \mixin{} collecting the operations
and properties that are needed in order to enrich a monoid to a ring, hence
the name \coq{Ring_of_Monoid}. Indeed this time the type variable \coq{A}
is followd by \coq{Monoid.axioms} that enriches
\coq{A} with the operations and properties of monoids. As a consequence
\coq{add} and \coq{zero} can be used to express the new properties.

The last line declares the structure \coq{Ring} to hold all the axioms declared
so far. We can now inspect the contents of the hierarchy and then
proceed to build a theory about abstract rings,
register examples (instances) of ring structures
and finally use the abstract theory on these examples.

\begin{coqcode}
Print Monoid.type. (* Monoid.type  :=  { sort : Type;  ... }                           *) #\label{demo:theory:print:type}#
Check @add.        (* add          :   forall M : Monoid.type, M -> M -> M             *) #\label{demo:theory:check:add}#
Check @addNr.      (* addNr        :   forall R : Ring.type, left_inverse zero opp add *) #\label{demo:theory:check:addNr}#

Lemma addrC : forall R : Ring.type, commutative (@add R).                       #\label{demo:theory:state:addrC}#
Proof. (* Proof by Hankel 1867, omitted for brevity *) Qed.

Definition Z_Monoid_axioms : Monoid_of_Type.axioms Z :=                         #\label{demo:theory:z:monoid:axioms}#
  Monoid_of_Type.Axioms Z 0 Z.add
    Z.add_assoc Z.add_0_l Z.add_0_r.

Elpi hb.canonical Z Z_Monoid_axioms.                                            #\label{demo:theory:z:monoid:canonical}#

Definition Z_Ring_axioms : Ring_of_Monoid.axioms Z _ :=                        #\label{demo:theory:z:ring:axioms}#
  Ring_of_Monoid.Axioms Z 1 Z.opp Z.mul
    Z.add_opp_diag_l Z.add_opp_diag_r Z.mul_assoc Z.mul_1_l Z.mul_1_r
    Z.mul_add_distr_r Z.mul_add_distr_l.

Elpi hb.canonical Z Z_Ring_axioms.                                              #\label{demo:theory:z:ring:canonical}#

Lemma exercise (m n : Z) : (n + m) - n * 1 = m.
Proof. by rewrite mulr1 (addrC n) -(addrA m) addrN addr0. Qed.
\end{coqcode}

We can print the type for monoids as forged by \HB{} (line~\ref{demo:theory:print:type}).
It packs a carrier, called \coq{sort}, and the collection of operation and
properties that we omit for brevity.  We can also look at the type of two
constants synthesized by \HB{} out of the hierarchy declaration. Remark that
while the names of the constants come from the the names of \mixin{} fields,
their types differ.
In particular they are quantified over a \coq{Monoid.type} or \coq{Ring.type},
and not a simple type \coq{A} as in the \mixins{}. Moreover we evince that
the \coq{sort} projection is declared as an implicit coercion~\cite{Saibi97}
and is automatically inserted in order to make \coq{M -> M -> M} a meaningful
type for binary operations on the carrier of \coq{M}. Last, we see that
properties are quantified on (hence apply to) the structure they belong to but
use, in their statements, operations belonging to simpler structures.
For example \coq{addNr} is a property of a ring but  its statement mentions \coq{add},\
the operation of the underlying monoid.

We then follow the proof of Hankel~\cite{nearrings} to show that
ring axioms imply the commutativity of the underlying monoid
(line~\ref{demo:theory:state:addrC}). This simple example shows we can
populate the theory of abstract rings with new results.

We use the \coq{Monoid_of_Type.Axioms} \emph{\packager{}}
(line~\ref{demo:theory:z:monoid:axioms})
in order to build an instance of the \coq{Monoid}
structure for binary integers \coq{Z}.
We then register that monoid instance as the canonical one on \coq{Z}
(line~\ref{demo:theory:z:monoid:canonical}) via the command
\coq{hb.canonical}.
We can similarly declare that \coq{Z} forms a ring by using
the \coq{Ring_of_Monoid.Axioms} \packager{}
(lines~\ref{demo:theory:z:ring:axioms} and~\ref{demo:theory:z:ring:canonical}).
Note that the \coq{Ring_of_Monoid.Axioms} \packager{} is not
a plain record constructor for \coq{Ring_of_Monoid.axioms}, since that
would require more arguments, namely the monoid ones (see the \coq{_}
at line~\ref{demo:theory:z:ring:axioms}). The
\packager{} synthesized by \HB{} infers them automatically
(as in~\cite[Section 7]{DBLP:conf/itp/MahboubiT13}) thanks to the \coq{hb.canonical}
declaration given just above.

From now on the axioms as well as the abstract theory of rings apply to
integers, as shown in lemma \coq{exercise}. The details of the proof
don't matter here, what is worth pointing out is that in a single
statement we mix monoid (e.g. \coq{+}) and ring (e.g. \coq{-}) operations and in the
proof we use monoid axioms (e.g. \coq{addrA}), ring axioms
(e.g. \coq{addrN}) and ring lemmas (e.g. \coq{addrC}), all seamlessly.

\subsection{Evolution of the hierarchy}\label{subsec:evolution}

We now proceed by changing the hierarchy to accommodate the intermediate
structure of Abelian groups.

\begin{coqcode}
#\hbmixin{}# Monoid_of_Type A.
  Record axioms := { ... (* unchanged *) ... }.
Elpi hb.end.
#\hbstructure{}# Monoid Monoid_of_Type.axioms.

#\hbmixin{}# AbelianGroup_of_Monoid A Monoid.axioms.
  Record axioms := {
    opp : A -> A;
    addrC : commutative (S := A) add;
    addNr : left_inverse zero opp add;
  }.
Elpi hb.end.
#\hbstructure{}# AbelianGroup Monoid.axioms AbelianGroup_of_Monoid.axioms.

#\hbmixin{}# Ring_of_AbelianGroup A AbelianGroup.axioms.
  Record axioms := {
    one : A;
    mul : A -> A -> A;
    mulrA : associative mul;
    mul1r : left_id one mul;
    mulr1 : right_id one mul;
    mulrDl : left_distributive mul add;
    mulrDr : right_distributive mul add;
  }.
Elpi hb.end.
#\hbstructure{}# Ring AbelianGroup.axioms Ring_of_AbelianGroup.axioms.

Lemma addrN {R : AbelianGroup.type} : right_inverse zero opp add.               #\label{demo2:proof:addrN}#
Proof. by move=>x; rewrite addrC addNr. Qed.
\end{coqcode}

Some operations and properties were moved from the old \mixin{} for rings
into a newborn \mixin{} \coq{AbelianGroup_of_Monoid} that gathers the
axioms needed to turn a monoid into an Abelian group. Consequently the \mixin{}
for rings is now called \coq{Ring_of_AbelianGroup} (instead of \coq{Ring_of_Monoid})
since it expects the type \coq{A} to be already an Abelian group and hence
gathers fewer axioms. \\
While operations moved from one structure to another, some properties
undergo a deep change in their status.
The lemma \coq{addrC} part of the abstract theory of
rings is now an axiom of Abelian groups, while \coq{addrN} is no more
an axiom of rings, but rather tha theorem of the abstract theory of Abelian
groups.

With this new version of the hierarchy, that we name V2, code written
for version V1 breaks. For example the declaration of the canonical ring over 
the integers fails, if only
because we don't have a \coq{Ring_of_Monoid.Axioms} \packager{} anymore.

Our objective is to obtain a version of the hierarchy, that we name V3, that does
not only feature Abelian groups but that is also backward compatible
with V1.

\subsection{The missing puzzle piece}

\begin{figure}[!h]
  \begin{center}
    \includegraphics[width=\textwidth]{puzzle.pdf}
  \end{center}
  \caption{\label{fig:puzzle}The evolution of the hierarchy. V3 is backward compatible with V1, while V2 is not.}
\end{figure}

The key to make a hierarchy evolve without breaking user code is the full
fledged notion of \emph{\factory{}} (the \mixins{} seen so far are degenerate,
trivial, \factories{}).

\Factories{}, like \mixins{}, are packages for operations and properties but are
not directly used in the definition of structures. Instead a \factory{} is
equipped with \emph{\builder{}s}: user provided pieces of code that extract
from the \factory{} the contents of \mixins{}, so that existing
\packager{}s can be used.

As depicted in figure~\ref{fig:puzzle} we change again the hierarchy
by declaring a \coq{Ring_of_Monoid} \factory{}, that, from the user point of view,
will look indistinguishable from the old \coq{Ring_of_Monoid} \mixin{}
and hence grant backward compatibility between this last version V3 and the
initial one V1.\marginpar{KS: the following \coq{axioms} record is the same as the second \coq{axioms} record in Sect.~2. We may omit its details.}

\begin{coqcode}
#\hbfactory{}# Ring_of_Monoid A Monoid.axioms.
  Record axioms := {
    one : A;
    opp : A -> A;
    mul : A -> A -> A;
    addNr : left_inverse zero opp add;
    addrN : right_inverse zero opp add;
    mulrA : associative mul;
    mul1r : left_id one mul;
    mulr1 : right_id one mul;
    mulrDl : left_distributive mul add;
    mulrDr : right_distributive mul add;
  }.

  Variable f : axioms.                                                          #\label{demo3:variable:f}#

  Lemma addrC : commutative add.
  Proof. (* Same proof as before *) Qed.

  Definition to_AbelianGroup_of_Monoid :=
    AbelianGroup_of_Monoid.Axioms A (opp f) addrC (addNr f). (* addrN unused *)
  Elpi hb.canonical A to_AbelianGroup_of_Monoid.

  Definition to_Ring_of_AbelianGroup :=
    Ring_of_AbelianGroup.Axioms A (one f) (mul f)
      (mulrA f) (mul1r f) (mulr1 f) (mulrDl f) (mulrDr f).
  Elpi hb.canonical A to_Ring_of_AbelianGroup.

Elpi hb.end.
\end{coqcode}

The record \coq{Ring_of_Monoid.axioms} is the same we declared as a \mixin{}
in version V1. In order to make a \factory{} out of it we equip it with
two definition that embody the \emph{\builder{}s}.
The first is \coq{to_AbelianGroup_of_Monoid} and
explain how to build an \coq{AbelianGroup} structure out of the \factory{}
axioms (named \coq{f}, line~\ref{demo3:variable:f}).
This construction is also registered as canonical for \coq{A},
so that the next construction \coq{to_Ring_of_AbelianGroup} can call
the \coq{Ring_of_AbelianGroup.Axioms} \packager{} that requires \coq{A} to be
an \coq{AbelianGroup}.
It is worth pointing out that the proof of \coq{addrC} we had in V1 is now
required in order to write the \builder{} for Abelian groups, while
the \coq{addrN} field is not used (the same statement is already part of
the theory of Abelian groups, see line~\ref{demo2:proof:addrN} of the previous
code snippet).

Thanks to this \factory{} we can now declare \coq{Z} to be an instance
of a ring using the \coq{Ring_of_Monoid.Axioms} \packager{}.
The associated \builder{}s generate, behind the scenes, instances of the
\coq{Ring_of_AbelianGroup.axioms} and \coq{AbelianGroup_of_Monoid.axioms} \mixins{}
that in turn are used to build instances of the \coq{AbelianGroup} and \coq{Ring}
structures. Indeed, when used in the context of the hierarchy version V3,
the command \coq{Elpi hb.canonical Z Z_Ring_axioms}
makes \coq{Z} an instance of \emph{both} structures, and not just the \coq{Ring}
one as in version V1.
Thanks to that the proof of \coq{example} can use the theory of
both structures, for example \coq{addrC} holds on Abelian groups,
\coq{addrA} holds on monoids, while \coq{addr1} holds on rings.
As a result the very same proof works on both
version V1 and V3.

Last, it is worth pointing out that the new factory makes the following
two lines equivalent (the former one was used in V1 to declare
the structure of rings). Indeed they both describe the same set of \mixins{}.

\begin{coqcode}
#\hbstructure{}# Ring Monoid.axioms Ring_of_Monoid.axioms.
#\hbstructure{}# Ring AbelianGroup.axioms Ring_of_AbelianGroup.axioms.
\end{coqcode}

This is another example of client code that would not break when the hierarchy
moves from V1 to V3: the client of the hierarchy is allowed to declare new
structures on top of existing ones.

\subsection{\HB{} in a nutshell}

By using \HB{} the hierarchy designer has the following freedoms and advantages.

\begin{itemize}
\item Operations and properties (axioms) are made available to the user
      as soon as they are used in a structure The hierarchy designer
      is free to move them from one to another and replace an axiom
      by a lemma and vice versa.
\item Structures cannot disappear but the way they are built may change.
      The hierarchy designer is free to split structures into smaller
      ones in order to better factor and reuse parts of the hierarchy
      and the library that follows it.
\item \Mixins{} cannot disappear but can change considerably
      in their implementation. A simple \mixin{} can becomes a full fledged
      \factory{} equipped with \builder{}s to ensure retro compatibility.
\item \HB{} high level commands compile to
      the discipline of Packed Classes (Coq modules, records, coercions,
      implicit arguments, canonical structure instances, notations,
      \packager{}s).
      This process lifts a considerable
      burden from the shoulders of the hierarchy designer and the final user
      that are no longer required to master the details of Packed Classes.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{\HB{} language}\label{sec:language}

\subsection{\HB{} terms}

We call \(\Lang{}\) the set of terms of Coq type theory. The terms
handled by \HB{} are subdivided in six categories, the \mixins{}
\(\M{}\), the \factories{} \(\F{}\), , \mixinbuilders{} \(\B{}\), the
\classes{} \(\C{}\), the \structures{} \(\Str{}\) and
\packagers{} \(\FP{}\).

\Mixins{}, \factories{} and instances are tagged by the user, through the
commands \hbmixin{}, \hbfactory{} and \hbinstance{}, and the user may
rely on their implementation. However structures and classes are
generated with the command \hbstructure{} and builders are generated
when using \hbinstance{} while declaring a \factory{}, and the user
may only refer to structure types, but should never rely on their
implementation, neither should they rely on explicit builders.


\begin{definition}[\M{}, mixins]
A \emph{\mixin{}} \(m \in \M{}\) is a Coq record with one of more parameters.
The first parameter must be a \coq{(T : Type)}, while the other parameters
are \mixins{} applied to \coq{T} and possibly $n$ other distinct \mixins{}. I.e.
\begin{coqcode}
Record #$m$# (T : Type) #\(\vect{\left(p_i : m_i\ T\ p_{\sigma(i,1)}\ \ldots\ p_{\sigma(i,n_i)}\right)}_{i \in \enum1n}\)# : Type := { .. }.
\end{coqcode}
where for all \(i \in \enum1n\) we have \(m_i \in \M{}\) and its
arguments is a sequence of size $n_i$ of the previously quantified
mixins, i.e. for all \(k \in \enum1{n_i}\), we
have \(\sigma(i,k) \in \enum1{i-1}\).
\end{definition}

We will use the abbreviation \(\pmp{n} = \vect{\left(p_i : m_i\ T\ p_{\sigma(i,1)}\ \ldots\ p_{\sigma(i,n_i)}\right)}_{i \in \enum1n}\)

\begin{definition}[\depone and \dep, mixin dependencies]
  Given \(m \in \M{}\), we define \(\depone{}(m) \in \powerset\M{}\)
  as the set of all \mixins{} that occur as parameters of \(m\), i.e.
  \(\depone{}(m) = \enum{m_1}{m_n}\), and
  \(\dep{} \in \powerset\M{} \to \powerset\M{}\) by
  \(\dep{}(M) = \bigcup_{m \in M} \depone{}(m)\).
\end{definition}


\begin{remark}For all \(i \in \enum1n\), we have
\(\depone{}(m_i) = \enum{m_{\sigma(i,1)}}{m_{\sigma(i,m_i)}}\).
\end{remark}

\begin{proposition}
\depone{} is transitively closed since records are well typed in the
empty context and describes a DAG since Coq does not admit circular
definitions: \(\dep{}(\dep{}(M)) \subset \dep{}(M)\)
\end{proposition}

\begin{definition}[\factories{} \F{}, \mixinbuilders{} \B{} and \from{}]
  A \emph{\mixinbuilder{}} \(\mu \in \B{}\) is any term which return type is
  a mixin \(m_{n+1} \in \M{}\), and which parameters are the carrier
  type \coq{(T: Type)}, an arbitrary number of distinct \mixins{}
  \(\enum{m_1}{m_n}\) and an additional argument \(f\), which we call
  a \emph{\factory{}}, and may depend on the \mixins{}.  I.e.
\begin{coqcode}
Definition f (T : Type) #$\pmp{n}$# : Type := ...
Definition #$\mu$# (T : Type) #$\pmp{n}$#: #\(f\ T\ p_1 \ldots p_n\)# -> #\(m_{n+1}\ T\ p_{\sigma(n+1,1)}\ \ldots\ p_{\sigma(n+1,n_i)}\)# := ...
\end{coqcode}

  We define \(\from{} (f, m_{n+1}) = \mu\) the unique \mixinbuilder{}
  that builds the mixin \(m_{n+1}\) from the factory \(f\).
\end{definition}

\begin{definition}[\provides{}, \requires{}]
  We define the following functions \begin{itemize}
  \item\( \requires{}_1(f) = \enum{m_1}{m_n}  \in \powerset\M{}\)
    the set of mixins a factory \(f \in \F{}\) depends on, thus requiring all the
    \mixinbuilders{} of a given factory to have the same set of
    dependency.
  \item\( \provides{}_1(f) = \{m | \from{}(f,m) \textrm{ is defined}\}
    \in \powerset\M{}\) the set of mixins that a factory
    \(f \in \F{}\) provides, through its \mixinbuilders{}.
  \end{itemize}
\end{definition}

\begin{proposition}
They validate the following properties for all \(f \in \F{}\):
  \begin{enumerate}
    \item\( \dep{}(\requires{}_1(f)) \subseteq \requires{}(f)\)
    \item\( \requires{}_1(f) \cap \provides{}_1(f) = \emptyset \)
    \item\( \forall m \in \provides{}_1(f),~ \from{}(f,m) \) is defined
  \end{enumerate}
\end{proposition}

Mixins are declared by the user as the fundamental building blocks of
a hierarchy, they are special cases of factories, as the next
proposition shows, and once declared they shall not be distinguished
from regular factories.

\begin{proposition}[\( \M{} \subseteq \F{} \)]
  \[\textrm{For all }m \in \M{}\textrm{ we have }\from(m,m) = \coq{fun T p_1 .. p_n (x :}\ m\ \coq{T p_1 .. p_n) => x)} \in \B{}, \]
  hence \(\requires{}(m) = \depone{}(m)\) and
  \(\provides{}(m) = \{m\} \).
\end{proposition}


\begin{definition}[\FP{}, \packagers{}]
A \packager{} \(\phi \in \FP{}\) is a notation which automatically finds
the mixin instances a factory depends on and takes as explicit argument
the contents of the factory. E.g.
\begin{coqcode}
Notation #$\phi$# T x_1 .. x_n := (...).
\end{coqcode}
\end{definition}
The conception of such notation relies on unification with phantom types \cite{DBLP:conf/itp/MahboubiT13}.

\begin{command} to declare a new mixin:
\begin{coqcode}
#\hbmixin{}# M T #$f_1\ \ldots\ f_n$#.
Record axioms := { .. }.
hb.end
\end{coqcode}
Creates a module \coq{M} with a record \coq{M.axioms_}, which depends
on the mixins \(\bigcup_{f \in \coq{fs}} \provides{}(f)\), and registers this
new record both as a mixin and a factory
 It also creates a \packager{} \coq{M.Axioms}
\end{command}

\begin{command} to declaring a new factory and generating new mixin builders:
\begin{coqcode}
#\hbfactory{}# M T #$f_1\ \ldots\ f_n$#.
Record axioms := { .. }.
Variable (a : axioms _).

#\hbinstance{}# T #$b_1$#.
...
#\hbinstance{}# T #$b_k$#.
hb.end
\end{coqcode}
  Creates a module \coq{M} with a record \coq{M.axioms_}, which
  depends on the mixins \(\bigcup_{f \in \coq{fs}} \provides{}(f)\),
  and registers this new record as factory. We then use the
  \factoryinstances{} \(b_1, \ldots, b_k\) provided by the user and
  derive \mixinbuilders{} from them.
\end{command}

\begin{definition}[\C{}, class]
A \class{} \coq{c} \(\in \C{}\) is a Coq record with with one parameter
\coq{(T : Type)}. The type of each field is a \mixin{} in \M{} applied to
\coq{T} and, if needed, any number of other fields:
\begin{coqcode}
Record c (T : Type) := { #\(p_1 : m_1\ T\)#; ..; #\(p_n : m_n\ T\ p_{\sigma(n,1)}\ \ldots p_{\sigma(n,n_n)}\)#}.
\end{coqcode}
We call \(\cdef{}(c) \in \powerset\M{}\) is the set of \mixins{} mentioned in the fields of the \class{},
i.e. \{\coq{m_1,m_2,..,m_n}\}.
Given that \class{} records are well typed in the empty context
the set of \mixin{} records is closed transitively.
Projections for parameters are trivially definable.
The implementation enforces that no two
\class{} records contains the same set of
\mixin{} (disregarding the order of the fields).

  They validate the following properties for all \(f \in \F{}\):
  \begin{enumerate}
    \item\( \exists c \in \C{},~ \cdef{}(c) = \requires{}(f) \cup \provides{}(f) \)
    \item\( \exists C \subseteq \C{},~\bigcup_{c\in C}\cdef{}(c) = \requires{}(f)\)
    \end{enumerate}
  \end{definition}


\begin{proposition}[\( \C{} \subseteq \F{} \)]
  forall \(m \in \cdef{}(c)\) we have \(\from{}(c,m_i) = p_i,\) and it
  follows that \(\requires{}_1(c)~=~\emptyset \),
  \(\provides{}_1(c)~=~\cdef{}(c).\)
\end{proposition}

\begin{definition}[\Str{} Structure]
A \structure{} \coq{s} \(\in \Str{}\) is a Coq record with with no parameters
and two fields. Its first field is \coq{(sort : Type)} and its second field is
\coq{(class : c sort)} for some \coq{c} \(\in \C{}\).
A structure is just a class closed with a sigma type on its parameter, hence
they are in bijection.
\end{definition}


\begin{command} to declare a class and structure:
\begin{coqcode}
#\hbstructure{}# M #\(f_1 \ldots f_n\)#
\end{coqcode}
  crafts a class \coq{M.class_of} $\in \C{}$ where
  $\cdef{}(c) = \provides{}\left(\enum{f_1}{f_n}\right) $ and the
  corresponding structure \coq{M.type} $\in \Str{}$, together with
  unification hints as described in Section~\ref{sec:target-lang}.
\end{command}

\begin{command} to declare an instance:
\begin{coqcode}
#\hbinstance{}# c #\(b_1 \ldots b_k\)#
\end{coqcode}
synthesizes terms in $\Lang{}$ corresponding to all the \mixins{} $M$
that can be build with \from{} and all the \classes{} / \structures{}
for which \( \cdef{}(c) \subseteq M \).
\end{command}

\subsection{Robustness property}

\subsection{Subclasses and joins}

\begin{definition}[\issubclass{} \(\in \C{}\times\C{}\), \subclass{}]\label{def:subclass}
  \(c1~\issubclass{}~c2\) iff \(\cdef{}(c2) \subseteq \cdef{}(c1)\)
  \end{definition}

\begin{definition}[\(\join{} \in \C{}\times\C{} \to \C{}\)]\label{def:join}
if \(c1, c2 \in \C{}\) and \(\cdef{}(c1) \cap \cdef{}(c2) \neq \emptyset\)
then \(\join{}(c1,c2)\) is the smallest, w.r.t. set inclusion, \class{} \(c\) such that
\(\cdef{}(c1) \cup \cdef{}(c2) \subseteq \cdef{}(c)\).
\end{definition}

\begin{remark}[]
\(\join{}(c1,c2)\) is a \subclass{} of both \(c1\) and \(c2\).
\end{remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The target language: Coq with Packed, flat, Classes}
\label{sec:target-lang}

The language of packed classes were introduces in
\cite{DBLP:conf/tphol/GarillotGMR09} and used directly to describe the
algebraic hierarchy of the Mathematical Components library.
It is based on a disciplined use of records and projections and
on the possibility of extending the elaborator of Coq
via the declaration of Canonical Structures instances.

\subsection{Describing structures with records and projections}

We describe mathematical structures with three kinds of dependent records: mixins, classes, and structures.
As shown in section \ref{sec:example}, a mixin gathers operators and axioms newly introduced by a structure.
As in \cite[section 2.4]{DBLP:conf/tphol/GarillotGMR09}\cite[section 2]{KSdraft}, a class record is parameterised by the carrier of type \coq{Type} and gathers all the operators and axioms of a structure by assembling mixins, and a structure \coq{type} bundles a carrier and its class instance, as follows.
\begin{coqcode}
Module Monoid.
Record axioms (T : Type) : Type :=
  Class { Monoid_of_Type_mixin : Monoid_of_Type.axioms T; }.
Structure type : Type := Pack { sort : Type; class : axioms sort; }.
End Monoid.
\end{coqcode}
The \coq{Monoid} module plays the role of a name space and forces us to write the qualified names such as \coq{Monoid.type}; thus allows us to reuse the same unqualified names for other structures, i.e., class and structure record can always be named as \coq{axioms} and \coq{type} respectively.

Mixins and classes are internal definitions to declare structures; in contrast, \coq{Monoid.type} is the interface of the monoid structure to reason about monoids.
As in section \ref{sec:example}, we declare \coq{Monoid.sort} as an implicit coercion and lift monoid operators and axioms from projections for the monoid mixin to definitions and lemmas for \coq{Monoid.type} as follows.
\begin{coqcode}
Coercion Monoid.sort : Monoid.type >-> Sortclass.

Definition zero {T : Monoid.type} : T :=
  Monoid_of_Type.zero T (Monoid.Monoid_of_Type_mixin T (Monoid.class T)).
Definition add {T : Monoid.type} : T -> T -> T :=
  Monoid_of_Type.add T (Monoid.Monoid_of_Type_mixin T (Monoid.class T)).
Lemma addrA {T : Monoid.type} : associative (@add T).
(* Two monoid axioms `add0r` and `addr0` are omitted. *)
\end{coqcode}

Next we define the Abelian groups.
Since the monoid structure is the bottom of this hierarchy, its class record consists only of the mixin to build monoids from scratch; in contrast, the class record of Abelian groups consists of monoid and Abelian group mixins as follows because Abelian groups inherit from monoids.
\begin{coqcode}
Module AbelianGroup.
Record axioms (T : Type) : Type := Class {
  Monoid_of_Type_mixin : Monoid_of_Type.axioms T;
  AbelianGroup_of_Monoid_mixin : AbelianGroup_of_Monoid.axioms T Monoid_of_Type_mixin; }.
Structure type : Type := Pack { sort : Type; class : axioms sort }.
End AbelianGroup.
\end{coqcode}

\begin{coqcode}
Coercion AbelianGroup.sort : AbelianGroup.type >-> Sortclass.
Coercion AbelianGroup_class_to_TYPE_class : AbelianGroup.axioms >-> Monoid.axioms.
Coercion AbelianGroup_to_Monoid (T : AbelianGroup.type) : Monoid.type :=
  Monoid.Pack (AbelianGroup.sort T) (AbelianGroup.class T).

Definition opp {T : AbelianGroup.type} : T -> T := ... .
(* Abelian group axioms `addrC` and `addNr` are omitted. *)
\end{coqcode}



\begin{coqcode}
Module SemiRing.
Record axioms (T : Type) : Type := Class {
  Monoid_of_Type_mixin : Monoid_of_Type.axioms T;
  SemiRing_of_Monoid_mixin : SemiRing_of_Monoid.axioms T Monoid_of_Type_mixin; }.
Structure type : Type := Pack { sort : Type; class : axioms sort; }.
End SemiRing.
\end{coqcode}

\begin{coqcode}
Coercion SemiRing.sort : SemiRing.type >-> Sortclass.
Coercion SemiRing_to_Monoid (T : SemiRing.type) : Monoid.type :=
  Monoid.Pack (SemiRing.sort T) (SemiRing.class T).

Definition one {T : SemiRing.type} : T := ... .
Definition mul {T : SemiRing.type} : T -> T -> T := ... .
(* 7 semiring axioms are omitted. *)
\end{coqcode}



\begin{coqcode}
Module Ring.
Record axioms (T : Type) : Type := Class {
  Monoid_of_Type_mixin : Monoid_of_Type.axioms T;
  SemiRing_of_Monoid_mixin : SemiRing_of_Monoid.axioms T Monoid_of_Type_mixin;
  AbelianGroup_of_Monoid_mixin : AbelianGroup_of_Monoid.axioms T Monoid_of_Type_mixin; }.
Structure type : Type := Pack { sort : Type; class : axioms sort; }.
End Ring.
\end{coqcode}

\begin{coqcode}
Coercion Ring.sort : Ring.type >-> Sortclass.
Coercion Ring_to_Monoid (T : Ring.type) : Monoid.type :=
   Monoid.Pack (Ring.sort T) (Ring.class T).
Coercion Ring_to_SemiRing (T : Ring.type) : SemiRing.type :=
  SemiRing.Pack (Ring.sort T) (Ring.class T).
Coercion Ring_to_AbelianGroup (T : Ring.type) : AbelianGroup.type :=
  AbelianGroup.Pack (Ring.sort T) (Ring.class T).
\end{coqcode}

\subsection{Linking structures and instances via Canonical Structures}

The mechanism of Canonical Structures~\cite{DBLP:conf/itp/MahboubiT13,Saibi99phd}
lets the user extend the elaborator of the Coq prover. This software component
takes in input a term as written by the user and has to infer all the missing
piece of information that is necessary to make the term well typed.

Example x + y * z

Here + and * come respectively from, but we are mising them, so we have
to find a common type that makes it work. This information comes from
the hierarchy and the links between the structures. The low level mechanism
is the unifier that compares p1 \_ = p2 \_ and has to find a common
superstructure...

The language lets us only write hints of the form p s = v, so we need two
of them here: (p1 s1 = p2 x) and (p1 y = p2 s2) for any x y.

Similarly one can apply an algebraic thoery to an instance (an example)
of a structure. Eg 1 * 2 + 3. The same mechanism of CS let us
extend the unifier to solve p1 \_ = nat.

\subsection{The flatten variant}

Describing a structure by proving a base class and a \mixin{} is very conveniet
if one does it by hand, since it is more concise that spelling out all the
\mixins{} by hand and is also closer to the user language one desires.

Since we are going to synthesize code automatically the have the freedom
to organize \mixins{} as we wish while retaining a compact user language.
We chose to generate classes from scartch, listing all the involved
\mixins{} since this more uniform.

TODO: Example of a by hand flatten class, maybe the one of the join.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The implementation in Coq-Elpi}\label{sec:implementation}

The implementation is based on the Elpi
extension language for Coq. In this section we introduce the features of the
programming language that came handy in the development of \HB{} and
comment a few code snippets.

Coq-Elpi~\cite{CoqElpi} is a Coq plugin embedding
Elpi and providing an
extensive, high level, API to access and script the Coq system at the
vernacular level.
This API lives in the \elpi{coq} namespace and lets one easily declare
records, coercions, canonical structures, modules, implicit arguments, etc.
The most basic Coq data type exposed to Elpi is the one of references to global
declarations:

\begin{elpicode}
kind gref  type.                 % The data type of references to global terms
type indt  inductive -> gref.    % eg: Coq.Init.Datatypes.nat
type indc  constructor -> gref.  % eg: Coq.Init.Datatypes.O
type const constant -> gref.     % eg: Coq.Init.Peano.plus
\end{elpicode}

The arguments of the three constructors are opaque to Elpi, that can only use
values of these types via dedicated APIs. For example the API for declaring
an inductive type will generate a value of type \elpi{inductive} that,
in the case of the type of natural numbers, is printed as \elpi{«nat»}.

Elpi~\cite{DBLP:conf/lpar/DunchevGCT15} is a dialect
of $\lambda$Prolog~\cite{Miller:2012:PHL:2331097}, an higher order
logic programming language that makes it easy to manipulate abstract syntax
tree with binders. Coq-Elpi takes full advantage of this capability by
representing Coq terms in Higher Order Abstract
Syntax~\cite{10.1145/53990.54010} style, reusing the binder of the programming
language in order to represent Coq's ones. Here an excerpt of the data
type of Coq terms:

\begin{elpicode}
kind term type.                              % The data type of Coq terms
type global gref -> term.                    % eg: nat, O, S, plus, ...
type fun    term -> (term -> term) -> term.  % eg: fun x : t => b(x)
type app    list term -> term.               % eg: app [hd|args]
... % all other term constructors are omitted for brevity
\end{elpicode}

Note that the \elpi{fun} constructor holds a $\lambda$Prolog function.
In this syntax the Coq term \coq{(fun x : nat => x x)} becomes
\elpi{(fun (global (indt «nat»)) x\ app[x, x])} where \elpi{x\} binds \elpi{x}
in the body of the function. Substitution of a bound variable for a term
can be computed by applying a term (of function type) to an argument.

Data types with binders are also used as input to high level APIs that build
terms behind the scenes. For example a Coq record is just an inductive type
and the API do declare one must allow the type of a field to depend on the
fields that comes before it. Note that the \elpi{field} constructor
takes a coercion flag, the name of the field, its type and binds a term
in the remaining record declaration.

\begin{elpicode}
kind indt-decl type.              % The type of an inductive type declaration
type record      string -> term -> string -> record-decl -> indt-decl.
type field       bool -> string -> term -> (term -> record-decl) -> record-decl.
type end-record  record-decl.
... % constructors for non-record inductive types are omitted for brevity

external pred coq.env.add-indt i:indt-decl, o:inductive.
external pred coq.CS.canonical-projections i:inductive, o:list (option constant).
\end{elpicode}

The \elpi{pred} keyword documents a the types and modes (input or output) of the
arguments of a predicate, while \elpi{external} signals that the
predicate is a builtin (in other words it is implemented in
OCaml rather than $\lambda$Prolog).

We comment these two builtin predicates and the \elpi{indt-decl} type
while looking at the code of \elpi{declare-structure} that is in charge
of scripting the following Coq code (given as a parameter \coq{axioms}):

\begin{coqcode}
Structure type : Type := Pack { sort : Type; class : axioms sort }.
\end{coqcode}

The following Elpi code builds the declaration, type checks it, adds it to the
Coq environment and finally returns the projections for the sort and the class
fields (it is handy to have them in the rest of the code).

\begin{elpicode}
pred declare-structure i:gref, o:term, o:term, o:term.

declare-structure ClassName Structure SortProjection ClassProjection :- std.do! [
  StructureDeclaration =
    record "type" {{ Type }} "Pack" (
      field tt "sort" {{ Type }} s\                        %\label{binder:sort}%
      field ff "class" (app [global ClassName, s]) _\
    end-record),
  coq.typecheck-indt-decl StructureDeclaration,
  coq.env.add-indt StructureDeclaration StructureName,     %\label{record:decl}%
  coq.CS.canonical-projections StructureName [some SortP, some ClassP],
  Structure = global (indt StructureName),
  SortProjection = global (const SortP),
  ClassProjection = global (const ClassP),
].
\end{elpicode}

Note that the binder \elpi{s\} at line \ref{binder:sort} lets one mention
the first field in the type of the second.
The syntax \elpi{{{ Type }}} is a quotation: it lets
one use the syntax of Coq to write an Elpi expression of type \elpi{term}.
The API \elpi{coq.CS.canonical-projection} lets us find the projections
automatically generated by Coq for a given record.
The last detail worth mentioning is that this program makes no use of
backtraking: the \elpi{std.do!} combinator signals that.

In the simple case of the structure record the number of fields, and hence
the number of binders, is fixed. On the contrary the class record has one
field per \mixin{} and each of them can depend on the previous ones.
In order to synthesize terms with binders in an inductive fashion (using
a recursive predicate) $\lambda$Prolog lets one postulate fresh nominal
constants using the \elpi{pi} operator and attach to the
nominal some knowledge in the form of a clause via the \elpi{=>} operator.
This process is called binder mobility: the binder is moved from
the data (that we are building) to the program (the context of the
current computation).
This feature is key to the following code that synthesizes the
declaration of the fields of the class record.

\begin{elpicode}
pred synthesize-fields.field-for-mixin i:mixinname, o:term.
pred synthesize-fields i:list mixinname, i:term, o:record-decl.

synthesize-fields [] _ Decl :- Decl = end-record.
synthesize-fields [M|ML] T Decl :- std.do! [
  get-mixin-modname M ModName,
  Name is ModName ^ "_mixin",                          %\label{craft:name}%
  dep1 M Deps,                                         %\label{deps:fetch}%
  std.map Deps synthesize-fields.field-for-mixin Args, %\label{deps:satisfy}%
  Type = app[ global M, T | Args ],                    %\label{build:type}%
  Decl = (field ff Name Type f\
          Fields f),
  pi m\                                                %\label{postulate:m}%
    synthesize-fields.field-for-mixin M m =>           %\label{postulate:satisfy}%
    synthesize-fields ML T (Fields m)                  %\label{rec:call}%
].
\end{elpicode}

The first predicate \elpi{synthesize-fields.field-for-mixin} is used
to link a \mixin{} to a nominal that corresponds to the record field
for that mixin. It has no clauses in the base program but some clauses
are added dynamically by \elpi{synthesize-fields}.

The second predicate proceeds by recursion on the (topologically sorted) list of \mixins{},
and terminates when the list is empty. If the list contains a \mixin{} \elpi{M}
then it crafts a \elpi{Name} for it (line~\ref{craft:name}),
fetches its dependencies (line~\ref{deps:fetch}) and
finds the (previously declared) record fields holding these \mixins{}
(line~\ref{deps:satisfy}).
The \elpi{(std.map L1 P L2)} predicate relates the two lists \elpi{L1} and
\elpi{L2} point wise using the predicate \elpi{P}.

Line~\ref{build:type} builds the type of the field: the \mixin{} name applied
to the type (sort) and all its dependencies.
Note that the \elpi{Fields} variable, representing the declaration of the
next fields, is under the binder for \elpi{f} (the current field).
In order to make the recursive call under that binder (line~\ref{rec:call})
and recursively process \elpi{ML} we postulate a nominal
\elpi{m} (line~\ref{postulate:m}) that is a term satisfying any
future dependency on the current \mixin{} (line~\ref{postulate:satisfy})
and we replace \elpi{f} by \elpi{m} in \elpi{Fields} by writing
\elpi{(Fields m)}.


% The code of \elpi{synthesize-fields} makes an idiomatic use
% of \elpi{=>} in $\lambda$Prolog: the current program is temporarily
% extended with a clause.
% 
% \marginpar{this may go}The same operation, but with a persistent
% effect, is made available by Coq-Elpi via a dedicated API to extend
% data bases. A data base is a named set of clauses and
% commands are typically built by accumulating specific clauses on top
% of a data base. Here an excerpt of the \verb+hierarchy.db+ data base and
% of the \elpi{declare_mixin} command. Text between \verb+lp:{{+ and \verb+}}+
% is Elpi code embedded in a Coq file. All the vernacular commands beginning
% with \coq{Elpi} are provided by the Coq-Elpi plugin.
% 
% \begin{coqcode}
% Elpi Db hierarchy.db lp:{{
%   pred dep1 o:mixinname, o:list mixinname.
%   ... % for brevity we omit class and join
% }}.
% Elpi Command declare_mixin.
% Elpi Accumulate Db hierarchy.db.
% Elpi Accumulate lp:{{
%   main [str S] :- !, std.do! [
%     coq.locate S M,
%     coq.env.typeof M Ty,
%     gather-mixin-dendencies Ty [] ML, % implementation omitted for brevity
%     coq.elpi.accumulate "hierarchy.db" (clause _ _ (dep1 M ML)),
%     ...
%   ].
%   main _ :- coq.error "Usage: declare_mixin <mixin>".
% }}.
% \end{coqcode}
% 
% Line 11 computes the dependencies of \mixin{} \elpi{M} given
% its type and line 12 crafs a clause for \elpi{dep1} and
% adds it to the data base \elpi{"hierarchy.db"}.
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\section{Benchmark}
%if we can port ssralg, or not... It would be nice, but maybe its a bit late.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Related work}
The most closely related work is the one about Packed Classes~\cite{DBLP:conf/tphol/GarillotGMR09} on which we
build. The main differences are that \HB{} is a higher level language
that is compiled down to (flat) Packed Classes. The systematic use of
\factories{} makes the user interface of a hierarchy stable under the insertion of
structures, a property that Packed Classes lacks.
Finally many of the intricacy of Packed Classes are hidden to the user by
the compilation step.
\marginpar{ET: I guess you have more to say here}

In~\cite{CaretteCombinators} Carette and O'Connor describe the language of
Theory Presentation Combinators that can be used to describe a hierarchy of
algebraic structures.
They focus on the categorical semantics of the language that is built upon
the category of context.
They don't describe any actual compilation to the language of a mainstream
interactive prover, indeed they claim their language to be mostly type theory
independent. We know they considered targeting type theory and the language
of unification hints~\cite{10.1007/978-3-642-03359-9_8}
(a super set of the one of Canonical Structures),
but we could not find any written trace of that. Language wise they provides
keywords such as \verb+combine+ and \verb+over+ to share (reuse) a property
when defining a new structure. For example in order to avoid restating
the commutativity property when defining Abelian groups they combine
a commutative monoid and a group forcing the subjacent monoid to coincide:
\begin{verbatim}
CommutativeGroup := combine CommutativeMonoid , Group over Monoid
\end{verbatim}
In our language \HB{} the same role is played by \emph{\mixins{}}.
A \mixin{} lets one write once and forall a property and abstract it over types
and operations so that it can be reused in all the structures that need it.
One operation \HB{} allows for but that does not seem to be possible in the
setting of Presentation Combinators is the one of replacing an axioms with a
lemma and vice versa. As shown in \autoref{subsec:evolution} \HB{} supports
that.

The MMT system~\cite{RABE20131} provides a framework to describe formal
languages in a logical framework, providing good support for binders and
notations. It also provides an expressive module system to organize
theories and express relations among them in the form of functors.
At the time of writing
it provides limited support for elaborating user input taking systematic
advantage of the contents of the theories. The elaborator can be extended
by the user writing Scala code, and in principle use the contents of the
libraries to make sense of an incomplete expressions, but no higher level
language or mechanism is provided.

The library of the Mizar system features a hierarchy of algebraic
structures~\cite{7733265}. In spite of lacking dependent types, Mizar
provides the concept of attributed types and adjectives
that can be used to describe the signature of structures as one would
do with a dependently typed record and their properties as
one would define a conjunctive predicate.
The Mizar language also provides the notion of cluster that is used
to link structures: by showing that property $P$ implies property $Q$
one can inform automation that structures characterized by $P$ are
instances of structures characterized by $Q$. The foundational theory of Mizar
features by an extensional notion of equality that makes it easy
to share the signature or the properties of structures by just requiring
a proof of their equivalence that is in turn used by automation to treat
equivalent structures as equal.

\marginpar{
the word \factory{} comes from "the gang of four" design patterns, we
could cite it. Cyril sees a similarity between the AbstractFactory design
pattern and our notion of factory.
}

\subsection{Other target languages}\label{subsec:othertgt}
\marginpar{section \ref{subsec:othertgt} can be safely cut}
We could have chosen telescopes~\cite{telescopes} or unbundled
classes~\cite{mathclasses} as the target language for \HB{}.
We believe it would take only a minor effort to patch \coq{hierarchy-builder}
in order to represent structures in these ways.
At the same time the Mathematical Components library, given the size and
the depth of the hierarchy, adopts Packed Classes because they offer a good
compromise between flexibility and performance. See~\cite[Section 8]{DBLP:conf/itp/MahboubiT13}
for a comparison.
% , and is our objective to adopt \HB{} in that context as soon as possible.
At the same time one
can imagine a future were the Coq system will provide comparable
performances for unbundled classes.
It is a virtue of our work to provide a user language that is separate
from the implementation one, so we could in principle target any other
equally expressive language without the user noticing.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
In this paper we design and implement \HB{}, a high level language to describe
hierarchies of algebraic structures. The implementation of \HB{} is
based on the Elpi extension language for the Coq system and is available
at \url{https://github.com/math-comp/hierarchy-builder}.
The implementation amounts to approximately a thousand lines of (commented)
Elpi code and tree hundred lines of Coq vernacular. It took less than one month
to implement \HB{} while it took several years of attempts and fruitful
discussions with the other developers of the Mathematical Components library
to design it.\marginpar{Cyril, do you want to make names?}

The \HB{} language is only loosely tied to Coq or even Type Theory.
It could probably be adopted without major changes in other tools. Indeed the
properties and invariants that link \factories{}, \mixins{} and \classes{}
are key to rule out meaningless or ambiguous sentences and are not
specific to the logic setting on which a prover stands. Moreover
most logics feature packing construction similar to records and corresponding
projections.
The compilation scheme we present in \autoref{sec:target-lang} is of
course tied to dependent records
and Canonical Structures, features that are available in Coq but also
in other provers based on Type Theory such a Matita~\cite{DBLP:conf/cade/AspertiRCT11}
and Lean~\cite{DBLP:conf/cade/MouraKADR15}
that provide Unification Hints~\cite{10.1007/978-3-642-03359-9_8}, a strict
super language of Canonical Structures.

We leave to future work extending \HB{} to support structures parametrized
by structures such as the one of module over a ring.
We also leave to future
work the automatic synthesis of the notion of morphism between structures
of the hierarchy.

\bibliography{biblio}

\appendix

\section{Coq reference}

\begin{coqcode}
Section OperationProperties.
Variable T : Type.
Variable e : T.
Variable inv : T -> T.
Variable op : T -> T -> T.
Variable add : T -> T -> T.

Definition left_id  := forall x, op e x = x.
Definition right_id := forall x, op x e = x.

Definition left_inverse := forall x, op (inv x) x = e.

Definition commutative := forall x y, op x y = op y x.
Definition associative := forall x y z, op x (op y z) = op (op x y) z.

Definition left_distributive  := forall x y z, op (add x y) z = add (op x z) (op y z).
Definition right_distributive := forall x y z, op x (add y z) = add (op x y) (op x z).
\end{coqcode}

\section{Proof of addrC}
\begin{coqcode}
Lemma addrC {R : Ring.type} : commutative (@add R).
Proof.
have innerC (a b : R) : (a + b) + (a + b) = (a + a) + (b + b).
  by rewrite -[a+b]mul1r -mulrDl mulrDr !mulrDl !mul1r.
have addKl (a b c : R) : a + b = a + c -> b = c.
  apply: can_inj (add a) (add (-a)) _ _ _.
  by move=> x; rewrite addrA addNr add0r.
have addKr (a b c : R) : b + a = c + a -> b = c.
  apply: can_inj (add ^~ a) (add ^~ (-a)) _ _ _.
  by move=> x; rewrite /= -addrA addrN addr0.
move=> x y; apply: addKl (x) _ _ _; apply: addKr (y) _ _ _.
by rewrite -!addrA [in RHS]addrA innerC !addrA.
Qed.
\end{coqcode}

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "hb.tex"
%%% TeX-command-extra-options: "-shell-escape"
%%% ispell-local-dictionary: "english"
%%% End: